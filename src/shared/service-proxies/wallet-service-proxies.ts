//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const WALLET_API_BASE_URL = new InjectionToken<string>('WALLET_API_BASE_URL');

@Injectable()
export class CoBoCallBackServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transactionNotification(body: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/externalapis/CoBoCallBackService/TransactionNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransactionNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransactionNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransactionNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    withdrawalConfirmation(body: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/externalapis/CoBoCallBackService/WithdrawalConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWithdrawalConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWithdrawalConfirmation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWithdrawalConfirmation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CoBoServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAccountInfo(): Observable<CoBoAccountInfoDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetAccountInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoAccountInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoAccountInfoDto>;
        }));
    }

    protected processGetAccountInfo(response: HttpResponseBase): Observable<CoBoAccountInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoAccountInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoAccountInfoDto>(null as any);
    }

    /**
     * @return Success
     */
    getSupportedCoins(): Observable<CoBoSupportedCoinsDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetSupportedCoins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportedCoins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportedCoins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoSupportedCoinsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoSupportedCoinsDto>;
        }));
    }

    protected processGetSupportedCoins(response: HttpResponseBase): Observable<CoBoSupportedCoinsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoSupportedCoinsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoSupportedCoinsDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @return Success
     */
    getCoinInfo(coin: string | undefined): Observable<CoBoCoinDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetCoinInfo?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoinInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoinInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoCoinDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoCoinDto>;
        }));
    }

    protected processGetCoinInfo(response: HttpResponseBase): Observable<CoBoCoinDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoCoinDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoCoinDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @return Success
     */
    getNewDepositAddress(coin: string | undefined): Observable<CoBoAddressDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetNewDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoAddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoAddressDto>;
        }));
    }

    protected processGetNewDepositAddress(response: HttpResponseBase): Observable<CoBoAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoAddressDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param count (optional) 
     * @return Success
     */
    batchGetNewDepositAddress(coin: string | undefined, count: number | undefined): Observable<CoBoAddressesDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/BatchGetNewDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchGetNewDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchGetNewDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoAddressesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoAddressesDto>;
        }));
    }

    protected processBatchGetNewDepositAddress(response: HttpResponseBase): Observable<CoBoAddressesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoAddressesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoAddressesDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @return Success
     */
    verifyDepositAddress(coin: string | undefined, address: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/VerifyDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerifyDepositAddress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param addresses (optional) 
     * @return Success
     */
    batchVerifyDepositAddress(coin: string | undefined, addresses: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/BatchVerifyDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (addresses === null)
            throw new Error("The parameter 'addresses' cannot be null.");
        else if (addresses !== undefined)
            url_ += "addresses=" + encodeURIComponent("" + addresses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchVerifyDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchVerifyDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processBatchVerifyDepositAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @return Success
     */
    verifyValidAddress(coin: string | undefined, address: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/VerifyValidAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyValidAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyValidAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processVerifyValidAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAddressHistoryList(coin: string | undefined, pageIndex: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetAddressHistoryList?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressHistoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressHistoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAddressHistoryList(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @return Success
     */
    checkLoopAddressDetails(coin: string | undefined, address: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/CheckLoopAddressDetails?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckLoopAddressDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckLoopAddressDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCheckLoopAddressDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param addresses (optional) 
     * @return Success
     */
    verifyLoopAddressList(coin: string | undefined, addresses: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/VerifyLoopAddressList?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (addresses === null)
            throw new Error("The parameter 'addresses' cannot be null.");
        else if (addresses !== undefined)
            url_ += "addresses=" + encodeURIComponent("" + addresses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyLoopAddressList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyLoopAddressList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processVerifyLoopAddressList(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTransactionDetails(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @param maxId (optional) 
     * @return Success
     */
    getTransactionsById(coin: string | undefined, side: string | undefined, maxId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionsById?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        if (maxId === null)
            throw new Error("The parameter 'maxId' cannot be null.");
        else if (maxId !== undefined)
            url_ += "maxId=" + encodeURIComponent("" + maxId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionsById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param requestIds (optional) 
     * @return Success
     */
    getTransactionsByRequestIds(requestIds: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionsByRequestIds?";
        if (requestIds === null)
            throw new Error("The parameter 'requestIds' cannot be null.");
        else if (requestIds !== undefined)
            url_ += "requestIds=" + encodeURIComponent("" + requestIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionsByRequestIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsByRequestIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionsByRequestIds(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param txId (optional) 
     * @return Success
     */
    getTransactionByTxId(txId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionByTxId?";
        if (txId === null)
            throw new Error("The parameter 'txId' cannot be null.");
        else if (txId !== undefined)
            url_ += "txId=" + encodeURIComponent("" + txId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionByTxId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionByTxId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionByTxId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @param beginTime (optional) 
     * @return Success
     */
    getTransactionsByTime(coin: string | undefined, side: string | undefined, beginTime: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionsByTime?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        if (beginTime === null)
            throw new Error("The parameter 'beginTime' cannot be null.");
        else if (beginTime !== undefined)
            url_ += "beginTime=" + encodeURIComponent("" + beginTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionsByTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsByTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionsByTime(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @return Success
     */
    getPendingTransactions(coin: string | undefined, side: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetPendingTransactions?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetPendingTransactions(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPendingDepositDetails(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetPendingDepositDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingDepositDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingDepositDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetPendingDepositDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @return Success
     */
    getTransactionHistory(coin: string | undefined, side: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionHistory?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionHistory(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @param amount (optional) 
     * @param requestId (optional) 
     * @param memo (optional) 
     * @return Success
     */
    submitWithdrawalRequest(coin: string | undefined, address: string | undefined, amount: number | undefined, requestId: string | undefined, memo: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/SubmitWithdrawalRequest?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        if (memo === null)
            throw new Error("The parameter 'memo' cannot be null.");
        else if (memo !== undefined)
            url_ += "memo=" + encodeURIComponent("" + memo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitWithdrawalRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitWithdrawalRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSubmitWithdrawalRequest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param requestId (optional) 
     * @return Success
     */
    getWithdrawalInformation(requestId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetWithdrawalInformation?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWithdrawalInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWithdrawalInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetWithdrawalInformation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class CoinServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDefaultCoin(): Observable<CoinDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Coin/GetDefaultCoin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultCoin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultCoin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoinDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoinDtoResponseDto>;
        }));
    }

    protected processGetDefaultCoin(response: HttpResponseBase): Observable<CoinDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoinDtoResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    get(): Observable<CoinDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/Coin/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoinDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoinDtoIEnumerableResponseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CoinDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoinDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    getById(id: string): Observable<CoinDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Coin/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoinDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoinDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CoinDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoinDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateCoinsDto | undefined): Observable<CoinDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Coin/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoinDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoinDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<CoinDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoinDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CoinDto | undefined): Observable<CoinDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Coin/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoinDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoinDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CoinDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoinDtoResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<CoinDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Coin/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoinDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoinDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<CoinDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoinDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<CoinDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/Coin/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoinDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoinDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CoinDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoinDtoPagedListResponseDto>(null as any);
    }
}

@Injectable()
export class ConfigSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Observable<ConfigSettingsDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoIEnumerableResponseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ConfigSettingsDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    getById(id: number): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateConfigSettingsDto | undefined): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ConfigSettingsDto | undefined): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<ConfigSettingsDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ConfigSettingsDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoPagedListResponseDto>(null as any);
    }
}

@Injectable()
export class CyberPayCustoWalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param chainType (optional) 
     * @return Success
     */
    addWalletGroup(walletGroupName: string, chainType: CustoNetworks | undefined): Observable<CustoWalletGroupResponse> {
        let url_ = this.baseUrl + "/api/CyberPayCustoWallet/AddWalletGroup?";
        if (walletGroupName === undefined || walletGroupName === null)
            throw new Error("The parameter 'walletGroupName' must be defined and cannot be null.");
        else
            url_ += "WalletGroupName=" + encodeURIComponent("" + walletGroupName) + "&";
        if (chainType === null)
            throw new Error("The parameter 'chainType' cannot be null.");
        else if (chainType !== undefined)
            url_ += "chainType=" + encodeURIComponent("" + chainType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWalletGroupResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWalletGroupResponse>;
        }));
    }

    protected processAddWalletGroup(response: HttpResponseBase): Observable<CustoWalletGroupResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWalletGroupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWalletGroupResponse>(null as any);
    }

    /**
     * @param walletGroupName (optional) 
     * @return Success
     */
    getWalletGroup(walletGroupName: string | undefined): Observable<CustoWalletGroupResponse> {
        let url_ = this.baseUrl + "/api/CyberPayCustoWallet/GetWalletGroup?";
        if (walletGroupName === null)
            throw new Error("The parameter 'walletGroupName' cannot be null.");
        else if (walletGroupName !== undefined)
            url_ += "WalletGroupName=" + encodeURIComponent("" + walletGroupName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWalletGroupResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWalletGroupResponse>;
        }));
    }

    protected processGetWalletGroup(response: HttpResponseBase): Observable<CustoWalletGroupResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWalletGroupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWalletGroupResponse>(null as any);
    }

    /**
     * @return Success
     */
    addWallet(walletGroupId: string, chainType: CustoNetworks): Observable<CustoWalletGroupResponse> {
        let url_ = this.baseUrl + "/api/CyberPayCustoWallet/AddWallet?";
        if (walletGroupId === undefined || walletGroupId === null)
            throw new Error("The parameter 'walletGroupId' must be defined and cannot be null.");
        else
            url_ += "WalletGroupId=" + encodeURIComponent("" + walletGroupId) + "&";
        if (chainType === undefined || chainType === null)
            throw new Error("The parameter 'chainType' must be defined and cannot be null.");
        else
            url_ += "chainType=" + encodeURIComponent("" + chainType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWalletGroupResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWalletGroupResponse>;
        }));
    }

    protected processAddWallet(response: HttpResponseBase): Observable<CustoWalletGroupResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWalletGroupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWalletGroupResponse>(null as any);
    }

    /**
     * @param walletAddress (optional) 
     * @return Success
     */
    getWallet(walletAddress: string | undefined): Observable<CustoWallet> {
        let url_ = this.baseUrl + "/api/CyberPayCustoWallet/GetWallet?";
        if (walletAddress === null)
            throw new Error("The parameter 'walletAddress' cannot be null.");
        else if (walletAddress !== undefined)
            url_ += "WalletAddress=" + encodeURIComponent("" + walletAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWallet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWallet>;
        }));
    }

    protected processGetWallet(response: HttpResponseBase): Observable<CustoWallet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWallet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWallet>(null as any);
    }

    /**
     * @return Success
     */
    transfer(toAddress: string, amount: string, symbol: CustoSymbols): Observable<CustoTransferResponse> {
        let url_ = this.baseUrl + "/api/CyberPayCustoWallet/Transfer?";
        if (toAddress === undefined || toAddress === null)
            throw new Error("The parameter 'toAddress' must be defined and cannot be null.");
        else
            url_ += "toAddress=" + encodeURIComponent("" + toAddress) + "&";
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined and cannot be null.");
        else
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (symbol === undefined || symbol === null)
            throw new Error("The parameter 'symbol' must be defined and cannot be null.");
        else
            url_ += "Symbol=" + encodeURIComponent("" + symbol) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransfer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoTransferResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoTransferResponse>;
        }));
    }

    protected processTransfer(response: HttpResponseBase): Observable<CustoTransferResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoTransferResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoTransferResponse>(null as any);
    }

    /**
     * @param transactionHash (optional) 
     * @return Success
     */
    getTransactionRecord(transactionHash: string | undefined): Observable<CustoTransactionRecordResponse> {
        let url_ = this.baseUrl + "/api/CyberPayCustoWallet/GetTransactionRecord?";
        if (transactionHash === null)
            throw new Error("The parameter 'transactionHash' cannot be null.");
        else if (transactionHash !== undefined)
            url_ += "transactionHash=" + encodeURIComponent("" + transactionHash) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionRecord(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoTransactionRecordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoTransactionRecordResponse>;
        }));
    }

    protected processGetTransactionRecord(response: HttpResponseBase): Observable<CustoTransactionRecordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoTransactionRecordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoTransactionRecordResponse>(null as any);
    }
}

@Injectable()
export class MockCustoWalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param chainType (optional) 
     * @return Success
     */
    addWalletGroup(walletGroupName: string, chainType: CustoNetworks | undefined): Observable<CustoWalletGroupResponse> {
        let url_ = this.baseUrl + "/api/MockCustoWallet/AddWalletGroup?";
        if (walletGroupName === undefined || walletGroupName === null)
            throw new Error("The parameter 'walletGroupName' must be defined and cannot be null.");
        else
            url_ += "WalletGroupName=" + encodeURIComponent("" + walletGroupName) + "&";
        if (chainType === null)
            throw new Error("The parameter 'chainType' cannot be null.");
        else if (chainType !== undefined)
            url_ += "chainType=" + encodeURIComponent("" + chainType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWalletGroupResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWalletGroupResponse>;
        }));
    }

    protected processAddWalletGroup(response: HttpResponseBase): Observable<CustoWalletGroupResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWalletGroupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWalletGroupResponse>(null as any);
    }

    /**
     * @param walletGroupName (optional) 
     * @return Success
     */
    getWalletGroup(walletGroupName: string | undefined): Observable<CustoWalletGroupResponse> {
        let url_ = this.baseUrl + "/api/MockCustoWallet/GetWalletGroup?";
        if (walletGroupName === null)
            throw new Error("The parameter 'walletGroupName' cannot be null.");
        else if (walletGroupName !== undefined)
            url_ += "WalletGroupName=" + encodeURIComponent("" + walletGroupName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWalletGroupResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWalletGroupResponse>;
        }));
    }

    protected processGetWalletGroup(response: HttpResponseBase): Observable<CustoWalletGroupResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWalletGroupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWalletGroupResponse>(null as any);
    }

    /**
     * @return Success
     */
    addWallet(walletGroupId: string, chainType: CustoNetworks): Observable<CustoWalletGroupResponse> {
        let url_ = this.baseUrl + "/api/MockCustoWallet/AddWallet?";
        if (walletGroupId === undefined || walletGroupId === null)
            throw new Error("The parameter 'walletGroupId' must be defined and cannot be null.");
        else
            url_ += "WalletGroupId=" + encodeURIComponent("" + walletGroupId) + "&";
        if (chainType === undefined || chainType === null)
            throw new Error("The parameter 'chainType' must be defined and cannot be null.");
        else
            url_ += "chainType=" + encodeURIComponent("" + chainType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWalletGroupResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWalletGroupResponse>;
        }));
    }

    protected processAddWallet(response: HttpResponseBase): Observable<CustoWalletGroupResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWalletGroupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWalletGroupResponse>(null as any);
    }

    /**
     * @param walletAddress (optional) 
     * @return Success
     */
    getWallet(walletAddress: string | undefined): Observable<CustoWallet> {
        let url_ = this.baseUrl + "/api/MockCustoWallet/GetWallet?";
        if (walletAddress === null)
            throw new Error("The parameter 'walletAddress' cannot be null.");
        else if (walletAddress !== undefined)
            url_ += "WalletAddress=" + encodeURIComponent("" + walletAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoWallet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoWallet>;
        }));
    }

    protected processGetWallet(response: HttpResponseBase): Observable<CustoWallet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoWallet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoWallet>(null as any);
    }

    /**
     * @return Success
     */
    transfer(toAddress: string, amount: string, symbol: CustoSymbols): Observable<CustoTransferResponse> {
        let url_ = this.baseUrl + "/api/MockCustoWallet/Transfer?";
        if (toAddress === undefined || toAddress === null)
            throw new Error("The parameter 'toAddress' must be defined and cannot be null.");
        else
            url_ += "toAddress=" + encodeURIComponent("" + toAddress) + "&";
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined and cannot be null.");
        else
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (symbol === undefined || symbol === null)
            throw new Error("The parameter 'symbol' must be defined and cannot be null.");
        else
            url_ += "Symbol=" + encodeURIComponent("" + symbol) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransfer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoTransferResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoTransferResponse>;
        }));
    }

    protected processTransfer(response: HttpResponseBase): Observable<CustoTransferResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoTransferResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoTransferResponse>(null as any);
    }

    /**
     * @param transactionHash (optional) 
     * @return Success
     */
    getTransactionRecord(transactionHash: string | undefined): Observable<CustoTransactionRecordResponse> {
        let url_ = this.baseUrl + "/api/MockCustoWallet/GetTransactionRecord?";
        if (transactionHash === null)
            throw new Error("The parameter 'transactionHash' cannot be null.");
        else if (transactionHash !== undefined)
            url_ += "transactionHash=" + encodeURIComponent("" + transactionHash) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionRecord(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustoTransactionRecordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustoTransactionRecordResponse>;
        }));
    }

    protected processGetTransactionRecord(response: HttpResponseBase): Observable<CustoTransactionRecordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustoTransactionRecordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustoTransactionRecordResponse>(null as any);
    }
}

@Injectable()
export class TfaGrpcClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param twoFactorPin (optional) 
     * @return Success
     */
    validateTwoFactorPIN(userId: string | undefined, twoFactorPin: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TfaGrpcClient/ValidateTwoFactorPIN?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (twoFactorPin === null)
            throw new Error("The parameter 'twoFactorPin' cannot be null.");
        else if (twoFactorPin !== undefined)
            url_ += "TwoFactorPin=" + encodeURIComponent("" + twoFactorPin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateTwoFactorPIN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateTwoFactorPIN(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateTwoFactorPIN(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class WalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateWalletDto | undefined): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WalletDto | undefined): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCustoWallet(body: WalletDto | undefined): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/CreateCustoWallet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCustoWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCustoWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processCreateCustoWallet(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBalance(body: UpdateWalletBalanceDto | undefined): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/UpdateBalance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processUpdateBalance(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    investment(body: InvestmentDto | undefined): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Investment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processInvestment(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transfer(body: TransferDto | undefined): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Transfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransfer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processTransfer(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @param coinId (optional) 
     * @return Success
     */
    getAdminWalletsForCoinId(coinId: string | undefined): Observable<WalletDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetAdminWalletsForCoinId?";
        if (coinId === null)
            throw new Error("The parameter 'coinId' cannot be null.");
        else if (coinId !== undefined)
            url_ += "coinId=" + encodeURIComponent("" + coinId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminWalletsForCoinId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminWalletsForCoinId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetAdminWalletsForCoinId(response: HttpResponseBase): Observable<WalletDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    get(): Observable<WalletDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoIEnumerableResponseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WalletDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    getById(id: string): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<WalletDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<WalletDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<WalletDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WalletDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDtoPagedListResponseDto>(null as any);
    }
}

@Injectable()
export class WalletGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateWalletGroupDto | undefined): Observable<WalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<WalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WalletGroupDto | undefined): Observable<WalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCustoWalletGroup(body: WalletGroupDto | undefined): Observable<WalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/CreateCustoWalletGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCustoWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCustoWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoResponseDto>;
        }));
    }

    protected processCreateCustoWalletGroup(response: HttpResponseBase): Observable<WalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getByUserId(userId: string | undefined): Observable<WalletGroupDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<WalletGroupDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    getAdminWalletGroup(): Observable<WalletGroupDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetAdminWalletGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetAdminWalletGroup(response: HttpResponseBase): Observable<WalletGroupDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    get(): Observable<WalletGroupDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoIEnumerableResponseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WalletGroupDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    getById(id: string): Observable<WalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<WalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<WalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<WalletGroupDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WalletGroupDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupDtoPagedListResponseDto>(null as any);
    }
}

export class AddressAmount implements IAddressAmount {
    address: string | undefined;
    amount: number;

    constructor(data?: IAddressAmount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): AddressAmount {
        data = typeof data === 'object' ? data : {};
        let result = new AddressAmount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["amount"] = this.amount;
        return data;
    }

    clone(): AddressAmount {
        const json = this.toJSON();
        let result = new AddressAmount();
        result.init(json);
        return result;
    }
}

export interface IAddressAmount {
    address: string | undefined;
    amount: number;
}

export class CoBoAccountInfoDto implements ICoBoAccountInfoDto {
    name: string | undefined;
    assets: CoBoAssetDto[] | undefined;

    constructor(data?: ICoBoAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets.push(CoBoAssetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CoBoAccountInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        return data;
    }

    clone(): CoBoAccountInfoDto {
        const json = this.toJSON();
        let result = new CoBoAccountInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAccountInfoDto {
    name: string | undefined;
    assets: CoBoAssetDto[] | undefined;
}

export class CoBoAddressDto implements ICoBoAddressDto {
    coin: string | undefined;
    address: string | undefined;

    constructor(data?: ICoBoAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CoBoAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["address"] = this.address;
        return data;
    }

    clone(): CoBoAddressDto {
        const json = this.toJSON();
        let result = new CoBoAddressDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAddressDto {
    coin: string | undefined;
    address: string | undefined;
}

export class CoBoAddressesDto implements ICoBoAddressesDto {
    coin: string | undefined;
    addresses: string[] | undefined;

    constructor(data?: ICoBoAddressesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses.push(item);
            }
        }
    }

    static fromJS(data: any): CoBoAddressesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAddressesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item);
        }
        return data;
    }

    clone(): CoBoAddressesDto {
        const json = this.toJSON();
        let result = new CoBoAddressesDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAddressesDto {
    coin: string | undefined;
    addresses: string[] | undefined;
}

export class CoBoAssetDto implements ICoBoAssetDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    require_memo: boolean;
    minimum_deposit_threshold: string | undefined;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;
    abs_estimate_fee_usd: string | undefined;
    confirming_threshold: number;
    dust_threshold: number;
    token_address: string | undefined;

    constructor(data?: ICoBoAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.display_code = _data["display_code"];
            this.description = _data["description"];
            this._decimal = _data["_decimal"];
            this.can_deposit = _data["can_deposit"];
            this.can_withdraw = _data["can_withdraw"];
            this.require_memo = _data["require_memo"];
            this.minimum_deposit_threshold = _data["minimum_deposit_threshold"];
            this.balance = _data["balance"];
            this.abs_balance = _data["abs_balance"];
            this.fee_coin = _data["fee_coin"];
            this.abs_estimate_fee = _data["abs_estimate_fee"];
            this.abs_estimate_fee_usd = _data["abs_estimate_fee_usd"];
            this.confirming_threshold = _data["confirming_threshold"];
            this.dust_threshold = _data["dust_threshold"];
            this.token_address = _data["token_address"];
        }
    }

    static fromJS(data: any): CoBoAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["display_code"] = this.display_code;
        data["description"] = this.description;
        data["_decimal"] = this._decimal;
        data["can_deposit"] = this.can_deposit;
        data["can_withdraw"] = this.can_withdraw;
        data["require_memo"] = this.require_memo;
        data["minimum_deposit_threshold"] = this.minimum_deposit_threshold;
        data["balance"] = this.balance;
        data["abs_balance"] = this.abs_balance;
        data["fee_coin"] = this.fee_coin;
        data["abs_estimate_fee"] = this.abs_estimate_fee;
        data["abs_estimate_fee_usd"] = this.abs_estimate_fee_usd;
        data["confirming_threshold"] = this.confirming_threshold;
        data["dust_threshold"] = this.dust_threshold;
        data["token_address"] = this.token_address;
        return data;
    }

    clone(): CoBoAssetDto {
        const json = this.toJSON();
        let result = new CoBoAssetDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAssetDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    require_memo: boolean;
    minimum_deposit_threshold: string | undefined;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;
    abs_estimate_fee_usd: string | undefined;
    confirming_threshold: number;
    dust_threshold: number;
    token_address: string | undefined;
}

export class CoBoCoinDto implements ICoBoCoinDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;

    constructor(data?: ICoBoCoinDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.display_code = _data["display_code"];
            this.description = _data["description"];
            this._decimal = _data["_decimal"];
            this.can_deposit = _data["can_deposit"];
            this.can_withdraw = _data["can_withdraw"];
            this.balance = _data["balance"];
            this.abs_balance = _data["abs_balance"];
            this.fee_coin = _data["fee_coin"];
            this.abs_estimate_fee = _data["abs_estimate_fee"];
        }
    }

    static fromJS(data: any): CoBoCoinDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoCoinDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["display_code"] = this.display_code;
        data["description"] = this.description;
        data["_decimal"] = this._decimal;
        data["can_deposit"] = this.can_deposit;
        data["can_withdraw"] = this.can_withdraw;
        data["balance"] = this.balance;
        data["abs_balance"] = this.abs_balance;
        data["fee_coin"] = this.fee_coin;
        data["abs_estimate_fee"] = this.abs_estimate_fee;
        return data;
    }

    clone(): CoBoCoinDto {
        const json = this.toJSON();
        let result = new CoBoCoinDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoCoinDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;
}

export class CoBoSupportedCoinsDto implements ICoBoSupportedCoinsDto {
    success: boolean;
    result: CoBoCoinDto[] | undefined;

    constructor(data?: ICoBoSupportedCoinsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(CoBoCoinDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CoBoSupportedCoinsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoSupportedCoinsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }

    clone(): CoBoSupportedCoinsDto {
        const json = this.toJSON();
        let result = new CoBoSupportedCoinsDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoSupportedCoinsDto {
    success: boolean;
    result: CoBoCoinDto[] | undefined;
}

export class CoinDto implements ICoinDto {
    id: string;
    symbol: CustoSymbols;
    fSymbol: string | undefined;
    network: CustoNetworks;
    fNetwork: string | undefined;
    isActive: boolean;
    isDefault: boolean;

    constructor(data?: ICoinDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.fSymbol = _data["fSymbol"];
            this.network = _data["network"];
            this.fNetwork = _data["fNetwork"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CoinDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoinDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["fSymbol"] = this.fSymbol;
        data["network"] = this.network;
        data["fNetwork"] = this.fNetwork;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        return data;
    }

    clone(): CoinDto {
        const json = this.toJSON();
        let result = new CoinDto();
        result.init(json);
        return result;
    }
}

export interface ICoinDto {
    id: string;
    symbol: CustoSymbols;
    fSymbol: string | undefined;
    network: CustoNetworks;
    fNetwork: string | undefined;
    isActive: boolean;
    isDefault: boolean;
}

export class CoinDtoIEnumerableResponseDto implements ICoinDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: CoinDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: ICoinDtoIEnumerableResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(CoinDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): CoinDtoIEnumerableResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoinDtoIEnumerableResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): CoinDtoIEnumerableResponseDto {
        const json = this.toJSON();
        let result = new CoinDtoIEnumerableResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICoinDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: CoinDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class CoinDtoPagedListResponseDto implements ICoinDtoPagedListResponseDto {
    isSuccess: boolean;
    result: CoinDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: ICoinDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(CoinDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): CoinDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoinDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): CoinDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new CoinDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICoinDtoPagedListResponseDto {
    isSuccess: boolean;
    result: CoinDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class CoinDtoResponseDto implements ICoinDtoResponseDto {
    isSuccess: boolean;
    result: CoinDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: ICoinDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? CoinDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): CoinDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoinDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): CoinDtoResponseDto {
        const json = this.toJSON();
        let result = new CoinDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICoinDtoResponseDto {
    isSuccess: boolean;
    result: CoinDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class ConfigSettingsDto implements IConfigSettingsDto {
    id: number;
    name: string | undefined;
    value: string | undefined;

    constructor(data?: IConfigSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ConfigSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): ConfigSettingsDto {
        const json = this.toJSON();
        let result = new ConfigSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IConfigSettingsDto {
    id: number;
    name: string | undefined;
    value: string | undefined;
}

export class ConfigSettingsDtoIEnumerableResponseDto implements IConfigSettingsDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IConfigSettingsDtoIEnumerableResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(ConfigSettingsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): ConfigSettingsDtoIEnumerableResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSettingsDtoIEnumerableResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): ConfigSettingsDtoIEnumerableResponseDto {
        const json = this.toJSON();
        let result = new ConfigSettingsDtoIEnumerableResponseDto();
        result.init(json);
        return result;
    }
}

export interface IConfigSettingsDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class ConfigSettingsDtoPagedListResponseDto implements IConfigSettingsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IConfigSettingsDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(ConfigSettingsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): ConfigSettingsDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSettingsDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): ConfigSettingsDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new ConfigSettingsDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IConfigSettingsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class ConfigSettingsDtoResponseDto implements IConfigSettingsDtoResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IConfigSettingsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? ConfigSettingsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): ConfigSettingsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSettingsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): ConfigSettingsDtoResponseDto {
        const json = this.toJSON();
        let result = new ConfigSettingsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IConfigSettingsDtoResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class CreateCoinsDto implements ICreateCoinsDto {
    symbol: CustoSymbols;
    network: CustoNetworks;
    isActive: boolean;
    isDefault: boolean;

    constructor(data?: ICreateCoinsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.network = _data["network"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateCoinsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCoinsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["network"] = this.network;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        return data;
    }

    clone(): CreateCoinsDto {
        const json = this.toJSON();
        let result = new CreateCoinsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCoinsDto {
    symbol: CustoSymbols;
    network: CustoNetworks;
    isActive: boolean;
    isDefault: boolean;
}

export class CreateConfigSettingsDto implements ICreateConfigSettingsDto {
    name: string;
    value: string;

    constructor(data?: ICreateConfigSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateConfigSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConfigSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): CreateConfigSettingsDto {
        const json = this.toJSON();
        let result = new CreateConfigSettingsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateConfigSettingsDto {
    name: string;
    value: string;
}

export class CreateWalletDto implements ICreateWalletDto {
    walletGroupsId: string;
    coin: CoinDto;

    constructor(data?: ICreateWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.coin = new CoinDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletGroupsId = _data["walletGroupsId"];
            this.coin = _data["coin"] ? CoinDto.fromJS(_data["coin"]) : new CoinDto();
        }
    }

    static fromJS(data: any): CreateWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletGroupsId"] = this.walletGroupsId;
        data["coin"] = this.coin ? this.coin.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateWalletDto {
        const json = this.toJSON();
        let result = new CreateWalletDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWalletDto {
    walletGroupsId: string;
    coin: CoinDto;
}

export class CreateWalletGroupDto implements ICreateWalletGroupDto {

    constructor(data?: ICreateWalletGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CreateWalletGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWalletGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): CreateWalletGroupDto {
        const json = this.toJSON();
        let result = new CreateWalletGroupDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWalletGroupDto {
}

export enum CustoNetworks {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum CustoSymbols {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class CustoTransactionRecordResponse implements ICustoTransactionRecordResponse {
    transactionHash: string | undefined;
    custoSymbols: CustoSymbols;
    fromAddress: AddressAmount[] | undefined;
    toAddress: AddressAmount[] | undefined;
    status: CustoTransactionStatus;
    fee: number;

    constructor(data?: ICustoTransactionRecordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionHash = _data["transactionHash"];
            this.custoSymbols = _data["custoSymbols"];
            if (Array.isArray(_data["fromAddress"])) {
                this.fromAddress = [] as any;
                for (let item of _data["fromAddress"])
                    this.fromAddress.push(AddressAmount.fromJS(item));
            }
            if (Array.isArray(_data["toAddress"])) {
                this.toAddress = [] as any;
                for (let item of _data["toAddress"])
                    this.toAddress.push(AddressAmount.fromJS(item));
            }
            this.status = _data["status"];
            this.fee = _data["fee"];
        }
    }

    static fromJS(data: any): CustoTransactionRecordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustoTransactionRecordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionHash"] = this.transactionHash;
        data["custoSymbols"] = this.custoSymbols;
        if (Array.isArray(this.fromAddress)) {
            data["fromAddress"] = [];
            for (let item of this.fromAddress)
                data["fromAddress"].push(item.toJSON());
        }
        if (Array.isArray(this.toAddress)) {
            data["toAddress"] = [];
            for (let item of this.toAddress)
                data["toAddress"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["fee"] = this.fee;
        return data;
    }

    clone(): CustoTransactionRecordResponse {
        const json = this.toJSON();
        let result = new CustoTransactionRecordResponse();
        result.init(json);
        return result;
    }
}

export interface ICustoTransactionRecordResponse {
    transactionHash: string | undefined;
    custoSymbols: CustoSymbols;
    fromAddress: AddressAmount[] | undefined;
    toAddress: AddressAmount[] | undefined;
    status: CustoTransactionStatus;
    fee: number;
}

export enum CustoTransactionStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class CustoTransferResponse implements ICustoTransferResponse {
    transactionHash: string | undefined;

    constructor(data?: ICustoTransferResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionHash = _data["transactionHash"];
        }
    }

    static fromJS(data: any): CustoTransferResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustoTransferResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionHash"] = this.transactionHash;
        return data;
    }

    clone(): CustoTransferResponse {
        const json = this.toJSON();
        let result = new CustoTransferResponse();
        result.init(json);
        return result;
    }
}

export interface ICustoTransferResponse {
    transactionHash: string | undefined;
}

export class CustoWallet implements ICustoWallet {
    address: string | undefined;
    custoSymbols: CustoSymbols;
    balance: number;

    constructor(data?: ICustoWallet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.custoSymbols = _data["custoSymbols"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): CustoWallet {
        data = typeof data === 'object' ? data : {};
        let result = new CustoWallet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["custoSymbols"] = this.custoSymbols;
        data["balance"] = this.balance;
        return data;
    }

    clone(): CustoWallet {
        const json = this.toJSON();
        let result = new CustoWallet();
        result.init(json);
        return result;
    }
}

export interface ICustoWallet {
    address: string | undefined;
    custoSymbols: CustoSymbols;
    balance: number;
}

export class CustoWalletGroupResponse implements ICustoWalletGroupResponse {
    walletGroupId: string | undefined;
    wallet: CustoWallet[] | undefined;

    constructor(data?: ICustoWalletGroupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletGroupId = _data["walletGroupId"];
            if (Array.isArray(_data["wallet"])) {
                this.wallet = [] as any;
                for (let item of _data["wallet"])
                    this.wallet.push(CustoWallet.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustoWalletGroupResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustoWalletGroupResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletGroupId"] = this.walletGroupId;
        if (Array.isArray(this.wallet)) {
            data["wallet"] = [];
            for (let item of this.wallet)
                data["wallet"].push(item.toJSON());
        }
        return data;
    }

    clone(): CustoWalletGroupResponse {
        const json = this.toJSON();
        let result = new CustoWalletGroupResponse();
        result.init(json);
        return result;
    }
}

export interface ICustoWalletGroupResponse {
    walletGroupId: string | undefined;
    wallet: CustoWallet[] | undefined;
}

export class InvestmentDto implements IInvestmentDto {
    twoFactorPin: string;
    fromWalletId: string;
    amount: number;
    tpye: InvestmentType;

    constructor(data?: IInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twoFactorPin = _data["twoFactorPin"];
            this.fromWalletId = _data["fromWalletId"];
            this.amount = _data["amount"];
            this.tpye = _data["tpye"];
        }
    }

    static fromJS(data: any): InvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twoFactorPin"] = this.twoFactorPin;
        data["fromWalletId"] = this.fromWalletId;
        data["amount"] = this.amount;
        data["tpye"] = this.tpye;
        return data;
    }

    clone(): InvestmentDto {
        const json = this.toJSON();
        let result = new InvestmentDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentDto {
    twoFactorPin: string;
    fromWalletId: string;
    amount: number;
    tpye: InvestmentType;
}

export enum InvestmentType {
    _1 = 1,
    _2 = 2,
}

export class TransferDto implements ITransferDto {
    twoFactorPin: string;
    fromWalletId: string;
    toWalletId: string;
    amount: number;

    constructor(data?: ITransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twoFactorPin = _data["twoFactorPin"];
            this.fromWalletId = _data["fromWalletId"];
            this.toWalletId = _data["toWalletId"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twoFactorPin"] = this.twoFactorPin;
        data["fromWalletId"] = this.fromWalletId;
        data["toWalletId"] = this.toWalletId;
        data["amount"] = this.amount;
        return data;
    }

    clone(): TransferDto {
        const json = this.toJSON();
        let result = new TransferDto();
        result.init(json);
        return result;
    }
}

export interface ITransferDto {
    twoFactorPin: string;
    fromWalletId: string;
    toWalletId: string;
    amount: number;
}

export class UpdateWalletBalanceDto implements IUpdateWalletBalanceDto {
    id: string;
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    coin: CoinDto;
    balance: number;
    isActive: boolean;
    isCustoWalletCreated: boolean;
    amount: number;

    constructor(data?: IUpdateWalletBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.walletGroupsId = _data["walletGroupsId"];
            this.address = _data["address"];
            this.coin = _data["coin"] ? CoinDto.fromJS(_data["coin"]) : <any>undefined;
            this.balance = _data["balance"];
            this.isActive = _data["isActive"];
            this.isCustoWalletCreated = _data["isCustoWalletCreated"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): UpdateWalletBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWalletBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["walletGroupsId"] = this.walletGroupsId;
        data["address"] = this.address;
        data["coin"] = this.coin ? this.coin.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        data["isActive"] = this.isActive;
        data["isCustoWalletCreated"] = this.isCustoWalletCreated;
        data["amount"] = this.amount;
        return data;
    }

    clone(): UpdateWalletBalanceDto {
        const json = this.toJSON();
        let result = new UpdateWalletBalanceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWalletBalanceDto {
    id: string;
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    coin: CoinDto;
    balance: number;
    isActive: boolean;
    isCustoWalletCreated: boolean;
    amount: number;
}

export class WalletDto implements IWalletDto {
    id: string;
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    coin: CoinDto;
    balance: number;
    isActive: boolean;
    isCustoWalletCreated: boolean;

    constructor(data?: IWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.walletGroupsId = _data["walletGroupsId"];
            this.address = _data["address"];
            this.coin = _data["coin"] ? CoinDto.fromJS(_data["coin"]) : <any>undefined;
            this.balance = _data["balance"];
            this.isActive = _data["isActive"];
            this.isCustoWalletCreated = _data["isCustoWalletCreated"];
        }
    }

    static fromJS(data: any): WalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["walletGroupsId"] = this.walletGroupsId;
        data["address"] = this.address;
        data["coin"] = this.coin ? this.coin.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        data["isActive"] = this.isActive;
        data["isCustoWalletCreated"] = this.isCustoWalletCreated;
        return data;
    }

    clone(): WalletDto {
        const json = this.toJSON();
        let result = new WalletDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDto {
    id: string;
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    coin: CoinDto;
    balance: number;
    isActive: boolean;
    isCustoWalletCreated: boolean;
}

export class WalletDtoIEnumerableResponseDto implements IWalletDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: WalletDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletDtoIEnumerableResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(WalletDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletDtoIEnumerableResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoIEnumerableResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletDtoIEnumerableResponseDto {
        const json = this.toJSON();
        let result = new WalletDtoIEnumerableResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: WalletDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletDtoPagedListResponseDto implements IWalletDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(WalletDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new WalletDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletDtoResponseDto implements IWalletDtoResponseDto {
    isSuccess: boolean;
    result: WalletDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? WalletDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletDtoResponseDto {
        const json = this.toJSON();
        let result = new WalletDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDtoResponseDto {
    isSuccess: boolean;
    result: WalletDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletGroupDto implements IWalletGroupDto {
    id: string;
    userId: string;
    tagName: string | undefined;
    wallets: WalletDto[] | undefined;
    isActive: boolean;
    isMain: boolean;
    isCustoWalletGroupCreated: boolean;
    custoWalletGroupId: string | undefined;
    custoWalletGroupName: string | undefined;

    constructor(data?: IWalletGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.tagName = _data["tagName"];
            if (Array.isArray(_data["wallets"])) {
                this.wallets = [] as any;
                for (let item of _data["wallets"])
                    this.wallets.push(WalletDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.isMain = _data["isMain"];
            this.isCustoWalletGroupCreated = _data["isCustoWalletGroupCreated"];
            this.custoWalletGroupId = _data["custoWalletGroupId"];
            this.custoWalletGroupName = _data["custoWalletGroupName"];
        }
    }

    static fromJS(data: any): WalletGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["tagName"] = this.tagName;
        if (Array.isArray(this.wallets)) {
            data["wallets"] = [];
            for (let item of this.wallets)
                data["wallets"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["isMain"] = this.isMain;
        data["isCustoWalletGroupCreated"] = this.isCustoWalletGroupCreated;
        data["custoWalletGroupId"] = this.custoWalletGroupId;
        data["custoWalletGroupName"] = this.custoWalletGroupName;
        return data;
    }

    clone(): WalletGroupDto {
        const json = this.toJSON();
        let result = new WalletGroupDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupDto {
    id: string;
    userId: string;
    tagName: string | undefined;
    wallets: WalletDto[] | undefined;
    isActive: boolean;
    isMain: boolean;
    isCustoWalletGroupCreated: boolean;
    custoWalletGroupId: string | undefined;
    custoWalletGroupName: string | undefined;
}

export class WalletGroupDtoIEnumerableResponseDto implements IWalletGroupDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: WalletGroupDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletGroupDtoIEnumerableResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(WalletGroupDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletGroupDtoIEnumerableResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupDtoIEnumerableResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletGroupDtoIEnumerableResponseDto {
        const json = this.toJSON();
        let result = new WalletGroupDtoIEnumerableResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: WalletGroupDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletGroupDtoPagedListResponseDto implements IWalletGroupDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletGroupDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletGroupDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(WalletGroupDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletGroupDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletGroupDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new WalletGroupDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletGroupDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletGroupDtoResponseDto implements IWalletGroupDtoResponseDto {
    isSuccess: boolean;
    result: WalletGroupDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletGroupDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? WalletGroupDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletGroupDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletGroupDtoResponseDto {
        const json = this.toJSON();
        let result = new WalletGroupDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupDtoResponseDto {
    isSuccess: boolean;
    result: WalletGroupDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}