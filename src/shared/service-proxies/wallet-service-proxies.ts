//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const WALLET_API_BASE_URL = new InjectionToken<string>('WALLET_API_BASE_URL');

@Injectable()
export class CoBoServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAccountInfo(): Observable<CoBoAccountInfoDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetAccountInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoAccountInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoAccountInfoDto>;
        }));
    }

    protected processGetAccountInfo(response: HttpResponseBase): Observable<CoBoAccountInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoAccountInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoAccountInfoDto>(null as any);
    }

    /**
     * @return Success
     */
    getSupportedSymbols(): Observable<CoBoSupportedSymbolsDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetSupportedSymbols";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportedSymbols(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportedSymbols(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoSupportedSymbolsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoSupportedSymbolsDto>;
        }));
    }

    protected processGetSupportedSymbols(response: HttpResponseBase): Observable<CoBoSupportedSymbolsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoSupportedSymbolsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoSupportedSymbolsDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @return Success
     */
    getSymbolInfo(coin: string | undefined): Observable<CoBoSymbolsDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetSymbolInfo?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSymbolInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSymbolInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoSymbolsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoSymbolsDto>;
        }));
    }

    protected processGetSymbolInfo(response: HttpResponseBase): Observable<CoBoSymbolsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoSymbolsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoSymbolsDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @return Success
     */
    getNewDepositAddress(coin: string | undefined): Observable<CoBoAddressDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetNewDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoAddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoAddressDto>;
        }));
    }

    protected processGetNewDepositAddress(response: HttpResponseBase): Observable<CoBoAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoAddressDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param count (optional) 
     * @return Success
     */
    batchGetNewDepositAddress(coin: string | undefined, count: number | undefined): Observable<CoBoAddressesDto> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/BatchGetNewDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchGetNewDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchGetNewDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoBoAddressesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoBoAddressesDto>;
        }));
    }

    protected processBatchGetNewDepositAddress(response: HttpResponseBase): Observable<CoBoAddressesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoBoAddressesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoBoAddressesDto>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @return Success
     */
    verifyDepositAddress(coin: string | undefined, address: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/VerifyDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerifyDepositAddress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param addresses (optional) 
     * @return Success
     */
    batchVerifyDepositAddress(coin: string | undefined, addresses: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/BatchVerifyDepositAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (addresses === null)
            throw new Error("The parameter 'addresses' cannot be null.");
        else if (addresses !== undefined)
            url_ += "addresses=" + encodeURIComponent("" + addresses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchVerifyDepositAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchVerifyDepositAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processBatchVerifyDepositAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @return Success
     */
    verifyValidAddress(coin: string | undefined, address: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/VerifyValidAddress?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyValidAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyValidAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processVerifyValidAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAddressHistoryList(coin: string | undefined, pageIndex: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetAddressHistoryList?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressHistoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressHistoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAddressHistoryList(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @return Success
     */
    checkLoopAddressDetails(coin: string | undefined, address: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/CheckLoopAddressDetails?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckLoopAddressDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckLoopAddressDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCheckLoopAddressDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param addresses (optional) 
     * @return Success
     */
    verifyLoopAddressList(coin: string | undefined, addresses: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/VerifyLoopAddressList?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (addresses === null)
            throw new Error("The parameter 'addresses' cannot be null.");
        else if (addresses !== undefined)
            url_ += "addresses=" + encodeURIComponent("" + addresses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyLoopAddressList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyLoopAddressList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processVerifyLoopAddressList(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTransactionDetails(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @param maxId (optional) 
     * @return Success
     */
    getTransactionsById(coin: string | undefined, side: string | undefined, maxId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionsById?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        if (maxId === null)
            throw new Error("The parameter 'maxId' cannot be null.");
        else if (maxId !== undefined)
            url_ += "maxId=" + encodeURIComponent("" + maxId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionsById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param requestIds (optional) 
     * @return Success
     */
    getTransactionsByRequestIds(requestIds: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionsByRequestIds?";
        if (requestIds === null)
            throw new Error("The parameter 'requestIds' cannot be null.");
        else if (requestIds !== undefined)
            url_ += "requestIds=" + encodeURIComponent("" + requestIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionsByRequestIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsByRequestIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionsByRequestIds(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param txId (optional) 
     * @return Success
     */
    getTransactionByTxId(txId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionByTxId?";
        if (txId === null)
            throw new Error("The parameter 'txId' cannot be null.");
        else if (txId !== undefined)
            url_ += "txId=" + encodeURIComponent("" + txId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionByTxId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionByTxId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionByTxId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @param beginTime (optional) 
     * @return Success
     */
    getTransactionsByTime(coin: string | undefined, side: string | undefined, beginTime: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionsByTime?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        if (beginTime === null)
            throw new Error("The parameter 'beginTime' cannot be null.");
        else if (beginTime !== undefined)
            url_ += "beginTime=" + encodeURIComponent("" + beginTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionsByTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsByTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionsByTime(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @return Success
     */
    getPendingTransactions(coin: string | undefined, side: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetPendingTransactions?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetPendingTransactions(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPendingDepositDetails(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetPendingDepositDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingDepositDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingDepositDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetPendingDepositDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param side (optional) 
     * @return Success
     */
    getTransactionHistory(coin: string | undefined, side: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetTransactionHistory?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (side === null)
            throw new Error("The parameter 'side' cannot be null.");
        else if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetTransactionHistory(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param coin (optional) 
     * @param address (optional) 
     * @param amount (optional) 
     * @param requestId (optional) 
     * @param memo (optional) 
     * @return Success
     */
    submitWithdrawalRequest(coin: string | undefined, address: string | undefined, amount: number | undefined, requestId: string | undefined, memo: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/SubmitWithdrawalRequest?";
        if (coin === null)
            throw new Error("The parameter 'coin' cannot be null.");
        else if (coin !== undefined)
            url_ += "coin=" + encodeURIComponent("" + coin) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        if (memo === null)
            throw new Error("The parameter 'memo' cannot be null.");
        else if (memo !== undefined)
            url_ += "memo=" + encodeURIComponent("" + memo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitWithdrawalRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitWithdrawalRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSubmitWithdrawalRequest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param requestId (optional) 
     * @return Success
     */
    getWithdrawalInformation(requestId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/externalapis/CoBoServices/GetWithdrawalInformation?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWithdrawalInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWithdrawalInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetWithdrawalInformation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class ConfigSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateConfigSettingsDto | undefined): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ConfigSettingsDto | undefined): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<ConfigSettingsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ConfigSettingsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<ConfigSettingsDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/ConfigSettings/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSettingsDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSettingsDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ConfigSettingsDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSettingsDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSettingsDtoPagedListResponseDto>(null as any);
    }
}

@Injectable()
export class NetworksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: NetworksDto | undefined): Observable<NetworksDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Networks/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworksDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworksDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<NetworksDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworksDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworksDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: NetworksDto | undefined): Observable<NetworksDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Networks/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworksDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworksDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<NetworksDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworksDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworksDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<NetworksDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Networks/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworksDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworksDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<NetworksDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworksDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworksDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getNetworkById(id: number | undefined): Observable<NetworksDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Networks/GetNetworkById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNetworkById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNetworkById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworksDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworksDtoResponseDto>;
        }));
    }

    protected processGetNetworkById(response: HttpResponseBase): Observable<NetworksDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworksDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworksDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllNetworks(pageNumber: number | undefined, pageSize: number | undefined): Observable<NetworksDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/Networks/GetAllNetworks?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNetworks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNetworks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetworksDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetworksDtoPagedListResponseDto>;
        }));
    }

    protected processGetAllNetworks(response: HttpResponseBase): Observable<NetworksDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworksDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworksDtoPagedListResponseDto>(null as any);
    }
}

@Injectable()
export class SymbolsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: SymbolsDto | undefined): Observable<SymbolsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Symbols/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolsDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SymbolsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SymbolsDto | undefined): Observable<SymbolsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Symbols/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolsDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SymbolsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<SymbolsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Symbols/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolsDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SymbolsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | undefined): Observable<SymbolsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Symbols/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolsDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SymbolsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolsDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<SymbolsDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/Symbols/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolsDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolsDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SymbolsDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolsDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolsDtoPagedListResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    saveOrUpdateSymbolTable(): Observable<SymbolsDto[]> {
        let url_ = this.baseUrl + "/api/Symbols/SaveOrUpdateSymbolTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOrUpdateSymbolTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOrUpdateSymbolTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolsDto[]>;
        }));
    }

    protected processSaveOrUpdateSymbolTable(response: HttpResponseBase): Observable<SymbolsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SymbolsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolsDto[]>([null as any]);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSymbolById(id: string | undefined): Observable<EntitySymbolsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Symbols/GetSymbolById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSymbolById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSymbolById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntitySymbolsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntitySymbolsDtoResponseDto>;
        }));
    }

    protected processGetSymbolById(response: HttpResponseBase): Observable<EntitySymbolsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntitySymbolsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntitySymbolsDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllSymbols(pageNumber: number | undefined, pageSize: number | undefined): Observable<EntitySymbolsDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/Symbols/GetAllSymbols?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSymbols(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSymbols(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntitySymbolsDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntitySymbolsDtoPagedListResponseDto>;
        }));
    }

    protected processGetAllSymbols(response: HttpResponseBase): Observable<EntitySymbolsDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntitySymbolsDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntitySymbolsDtoPagedListResponseDto>(null as any);
    }
}

@Injectable()
export class WalletServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateWalletsDto | undefined): Observable<WalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletsDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<WalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WalletsDto | undefined): Observable<WalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletsDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<WalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletsDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<WalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | undefined): Observable<WalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletsDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletsDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<WalletsDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletsDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletsDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WalletsDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletsDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletsDtoPagedListResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createWallet(body: CreateWalletsDto | undefined): Observable<EntityWalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/CreateWallet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoResponseDto>;
        }));
    }

    protected processCreateWallet(response: HttpResponseBase): Observable<EntityWalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateWallet(body: UpdateWalletDto | undefined): Observable<EntityWalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/UpdateWallet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoResponseDto>;
        }));
    }

    protected processUpdateWallet(response: HttpResponseBase): Observable<EntityWalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWalletById(id: string | undefined): Observable<EntityWalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetWalletById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalletById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalletById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoResponseDto>;
        }));
    }

    protected processGetWalletById(response: HttpResponseBase): Observable<EntityWalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoResponseDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getByUserId(userId: string | undefined): Observable<EntityWalletsDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<EntityWalletsDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getByWalletGroupId(userId: string | undefined): Observable<EntityWalletsDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetByWalletGroupId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByWalletGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByWalletGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetByWalletGroupId(response: HttpResponseBase): Observable<EntityWalletsDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBalance(body: UpdateWalletBalanceDto | undefined): Observable<EntityWalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/UpdateBalance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoResponseDto>;
        }));
    }

    protected processUpdateBalance(response: HttpResponseBase): Observable<EntityWalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    investment(body: InvestmentDto | undefined): Observable<EntityWalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Investment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoResponseDto>;
        }));
    }

    protected processInvestment(response: HttpResponseBase): Observable<EntityWalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transfer(body: TransferDto | undefined): Observable<EntityWalletsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/Transfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransfer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoResponseDto>;
        }));
    }

    protected processTransfer(response: HttpResponseBase): Observable<EntityWalletsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoResponseDto>(null as any);
    }

    /**
     * @param network (optional) 
     * @return Success
     */
    getAdminWalletsByNetwork(network: string | undefined): Observable<EntityWalletsDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetAdminWalletsByNetwork?";
        if (network === null)
            throw new Error("The parameter 'network' cannot be null.");
        else if (network !== undefined)
            url_ += "network=" + encodeURIComponent("" + network) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminWalletsByNetwork(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminWalletsByNetwork(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletsDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletsDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetAdminWalletsByNetwork(response: HttpResponseBase): Observable<EntityWalletsDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletsDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletsDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveTransaction(body: ApproveTransactionDto | undefined): Observable<EntityTransactionsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/Wallet/ApproveTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityTransactionsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityTransactionsDtoResponseDto>;
        }));
    }

    protected processApproveTransaction(response: HttpResponseBase): Observable<EntityTransactionsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityTransactionsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityTransactionsDtoResponseDto>(null as any);
    }
}

@Injectable()
export class WalletGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateWalletGroupsDto | undefined): Observable<WalletGroupsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupsDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<WalletGroupsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupsDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WalletGroupsDto | undefined): Observable<WalletGroupsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupsDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WalletGroupsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<WalletGroupsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupsDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<WalletGroupsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupsDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | undefined): Observable<WalletGroupsDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupsDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupsDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WalletGroupsDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupsDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupsDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<WalletGroupsDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletGroupsDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletGroupsDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WalletGroupsDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletGroupsDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletGroupsDtoPagedListResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createWalletGroup(body: CreateWalletGroupsDto | undefined): Observable<EntityWalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/CreateWalletGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletGroupDtoResponseDto>;
        }));
    }

    protected processCreateWalletGroup(response: HttpResponseBase): Observable<EntityWalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateWalletGroup(body: EntityWalletGroupDto | undefined): Observable<EntityWalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/UpdateWalletGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletGroupDtoResponseDto>;
        }));
    }

    protected processUpdateWalletGroup(response: HttpResponseBase): Observable<EntityWalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWalletGroupById(id: string | undefined): Observable<EntityWalletGroupDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetWalletGroupById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalletGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalletGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletGroupDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletGroupDtoResponseDto>;
        }));
    }

    protected processGetWalletGroupById(response: HttpResponseBase): Observable<EntityWalletGroupDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletGroupDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletGroupDtoResponseDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getByUserId(userId: string | undefined): Observable<EntityWalletGroupDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletGroupDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletGroupDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<EntityWalletGroupDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletGroupDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletGroupDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    getAdminWalletGroup(): Observable<EntityWalletGroupDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/WalletGroups/GetAdminWalletGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminWalletGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminWalletGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletGroupDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletGroupDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetAdminWalletGroup(response: HttpResponseBase): Observable<EntityWalletGroupDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletGroupDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletGroupDtoIEnumerableResponseDto>(null as any);
    }
}

@Injectable()
export class WalletPoliciesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(WALLET_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CreateWalletPoliciesDto | undefined): Observable<WalletPoliciesDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletPoliciesDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletPoliciesDtoResponseDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<WalletPoliciesDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletPoliciesDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletPoliciesDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WalletPoliciesDto | undefined): Observable<WalletPoliciesDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletPoliciesDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletPoliciesDtoResponseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WalletPoliciesDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletPoliciesDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletPoliciesDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<WalletPoliciesDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletPoliciesDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletPoliciesDtoResponseDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<WalletPoliciesDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletPoliciesDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletPoliciesDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | undefined): Observable<WalletPoliciesDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletPoliciesDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletPoliciesDtoResponseDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WalletPoliciesDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletPoliciesDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletPoliciesDtoResponseDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAll(pageNumber: number | undefined, pageSize: number | undefined): Observable<WalletPoliciesDtoPagedListResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/GetAll?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletPoliciesDtoPagedListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletPoliciesDtoPagedListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WalletPoliciesDtoPagedListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WalletPoliciesDtoPagedListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletPoliciesDtoPagedListResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createWalletPolicy(body: CreateWalletPoliciesDto | undefined): Observable<EntityWalletPolicyDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/CreateWalletPolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWalletPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWalletPolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletPolicyDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletPolicyDtoResponseDto>;
        }));
    }

    protected processCreateWalletPolicy(response: HttpResponseBase): Observable<EntityWalletPolicyDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletPolicyDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletPolicyDtoResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateWalletPolicy(body: EntityWalletPolicyDto | undefined): Observable<EntityWalletPolicyDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/UpdateWalletPolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWalletPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWalletPolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletPolicyDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletPolicyDtoResponseDto>;
        }));
    }

    protected processUpdateWalletPolicy(response: HttpResponseBase): Observable<EntityWalletPolicyDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletPolicyDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletPolicyDtoResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWalletPolicyById(id: string | undefined): Observable<EntityWalletPolicyDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/GetWalletPolicyById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalletPolicyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalletPolicyById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletPolicyDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletPolicyDtoResponseDto>;
        }));
    }

    protected processGetWalletPolicyById(response: HttpResponseBase): Observable<EntityWalletPolicyDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletPolicyDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletPolicyDtoResponseDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getByDelegatedUserId(userId: string | undefined): Observable<EntityWalletPolicyDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/GetByDelegatedUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDelegatedUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDelegatedUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletPolicyDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletPolicyDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetByDelegatedUserId(response: HttpResponseBase): Observable<EntityWalletPolicyDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletPolicyDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletPolicyDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getByWalletId(userId: string | undefined): Observable<EntityWalletPolicyDtoIEnumerableResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/GetByWalletId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByWalletId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByWalletId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletPolicyDtoIEnumerableResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletPolicyDtoIEnumerableResponseDto>;
        }));
    }

    protected processGetByWalletId(response: HttpResponseBase): Observable<EntityWalletPolicyDtoIEnumerableResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletPolicyDtoIEnumerableResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletPolicyDtoIEnumerableResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agreeWalletPolicy(body: AgreeWalletPolicyDto | undefined): Observable<EntityWalletPolicyDtoResponseDto> {
        let url_ = this.baseUrl + "/api/WalletPolicies/AgreeWalletPolicy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreeWalletPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreeWalletPolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityWalletPolicyDtoResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityWalletPolicyDtoResponseDto>;
        }));
    }

    protected processAgreeWalletPolicy(response: HttpResponseBase): Observable<EntityWalletPolicyDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityWalletPolicyDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityWalletPolicyDtoResponseDto>(null as any);
    }
}

export class AgreeWalletPolicyDto implements IAgreeWalletPolicyDto {
    walletPolicyId: string;
    isAgree: boolean;

    constructor(data?: IAgreeWalletPolicyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletPolicyId = _data["walletPolicyId"];
            this.isAgree = _data["isAgree"];
        }
    }

    static fromJS(data: any): AgreeWalletPolicyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreeWalletPolicyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletPolicyId"] = this.walletPolicyId;
        data["isAgree"] = this.isAgree;
        return data;
    }

    clone(): AgreeWalletPolicyDto {
        const json = this.toJSON();
        let result = new AgreeWalletPolicyDto();
        result.init(json);
        return result;
    }
}

export interface IAgreeWalletPolicyDto {
    walletPolicyId: string;
    isAgree: boolean;
}

export class ApproveTransactionDto implements IApproveTransactionDto {
    transactionId: string;
    approve: boolean;

    constructor(data?: IApproveTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.approve = _data["approve"];
        }
    }

    static fromJS(data: any): ApproveTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["approve"] = this.approve;
        return data;
    }

    clone(): ApproveTransactionDto {
        const json = this.toJSON();
        let result = new ApproveTransactionDto();
        result.init(json);
        return result;
    }
}

export interface IApproveTransactionDto {
    transactionId: string;
    approve: boolean;
}

export class AssetDataDto implements IAssetDataDto {
    symbolsId: string;
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    walletsId: string;
    balance: number;
    onholdBalance: number;

    constructor(data?: IAssetDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolsId = _data["symbolsId"];
            this.symbol = _data["symbol"];
            this.symbolName = _data["symbolName"];
            this.network = _data["network"];
            this.networkName = _data["networkName"];
            this.walletsId = _data["walletsId"];
            this.balance = _data["balance"];
            this.onholdBalance = _data["onholdBalance"];
        }
    }

    static fromJS(data: any): AssetDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbolsId"] = this.symbolsId;
        data["symbol"] = this.symbol;
        data["symbolName"] = this.symbolName;
        data["network"] = this.network;
        data["networkName"] = this.networkName;
        data["walletsId"] = this.walletsId;
        data["balance"] = this.balance;
        data["onholdBalance"] = this.onholdBalance;
        return data;
    }

    clone(): AssetDataDto {
        const json = this.toJSON();
        let result = new AssetDataDto();
        result.init(json);
        return result;
    }
}

export interface IAssetDataDto {
    symbolsId: string;
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    walletsId: string;
    balance: number;
    onholdBalance: number;
}

export class AssetsDto implements IAssetsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    assetData: Bo_AssetDataDto;

    constructor(data?: IAssetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"] ? DateTime.fromISO(_data["createdTime"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedTime = _data["lastModifiedTime"] ? DateTime.fromISO(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.assetData = _data["assetData"] ? Bo_AssetDataDto.fromJS(_data["assetData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AssetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime ? this.createdTime.toString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toString() : <any>undefined;
        data["assetData"] = this.assetData ? this.assetData.toJSON() : <any>undefined;
        return data;
    }

    clone(): AssetsDto {
        const json = this.toJSON();
        let result = new AssetsDto();
        result.init(json);
        return result;
    }
}

export interface IAssetsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    assetData: Bo_AssetDataDto;
}

export class Bo_AssetDataDto implements IBo_AssetDataDto {
    symbolsId: string;
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    walletsId: string;
    balance: number;
    onholdBalance: number;

    constructor(data?: IBo_AssetDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolsId = _data["symbolsId"];
            this.symbol = _data["symbol"];
            this.symbolName = _data["symbolName"];
            this.network = _data["network"];
            this.networkName = _data["networkName"];
            this.walletsId = _data["walletsId"];
            this.balance = _data["balance"];
            this.onholdBalance = _data["onholdBalance"];
        }
    }

    static fromJS(data: any): Bo_AssetDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new Bo_AssetDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbolsId"] = this.symbolsId;
        data["symbol"] = this.symbol;
        data["symbolName"] = this.symbolName;
        data["network"] = this.network;
        data["networkName"] = this.networkName;
        data["walletsId"] = this.walletsId;
        data["balance"] = this.balance;
        data["onholdBalance"] = this.onholdBalance;
        return data;
    }

    clone(): Bo_AssetDataDto {
        const json = this.toJSON();
        let result = new Bo_AssetDataDto();
        result.init(json);
        return result;
    }
}

export interface IBo_AssetDataDto {
    symbolsId: string;
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    walletsId: string;
    balance: number;
    onholdBalance: number;
}

export class Bo_SymbolDataDto implements IBo_SymbolDataDto {
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    regex: string | undefined;
    decimalPlaces: number;
    transferFee: number;
    minTransferAmt: number;
    maxTransferAmt: number;
    isPopular: boolean;
    sort: number;
    logoURL: string | undefined;
    depositEnable: boolean;
    withdrawEnable: boolean;
    externalMinTransferAmt: number;
    externalMaxTransferAmt: number;
    isActive: boolean;
    isDefault: boolean;

    constructor(data?: IBo_SymbolDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.symbolName = _data["symbolName"];
            this.network = _data["network"];
            this.networkName = _data["networkName"];
            this.regex = _data["regex"];
            this.decimalPlaces = _data["decimalPlaces"];
            this.transferFee = _data["transferFee"];
            this.minTransferAmt = _data["minTransferAmt"];
            this.maxTransferAmt = _data["maxTransferAmt"];
            this.isPopular = _data["isPopular"];
            this.sort = _data["sort"];
            this.logoURL = _data["logoURL"];
            this.depositEnable = _data["depositEnable"];
            this.withdrawEnable = _data["withdrawEnable"];
            this.externalMinTransferAmt = _data["externalMinTransferAmt"];
            this.externalMaxTransferAmt = _data["externalMaxTransferAmt"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): Bo_SymbolDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new Bo_SymbolDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["symbolName"] = this.symbolName;
        data["network"] = this.network;
        data["networkName"] = this.networkName;
        data["regex"] = this.regex;
        data["decimalPlaces"] = this.decimalPlaces;
        data["transferFee"] = this.transferFee;
        data["minTransferAmt"] = this.minTransferAmt;
        data["maxTransferAmt"] = this.maxTransferAmt;
        data["isPopular"] = this.isPopular;
        data["sort"] = this.sort;
        data["logoURL"] = this.logoURL;
        data["depositEnable"] = this.depositEnable;
        data["withdrawEnable"] = this.withdrawEnable;
        data["externalMinTransferAmt"] = this.externalMinTransferAmt;
        data["externalMaxTransferAmt"] = this.externalMaxTransferAmt;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        return data;
    }

    clone(): Bo_SymbolDataDto {
        const json = this.toJSON();
        let result = new Bo_SymbolDataDto();
        result.init(json);
        return result;
    }
}

export interface IBo_SymbolDataDto {
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    regex: string | undefined;
    decimalPlaces: number;
    transferFee: number;
    minTransferAmt: number;
    maxTransferAmt: number;
    isPopular: boolean;
    sort: number;
    logoURL: string | undefined;
    depositEnable: boolean;
    withdrawEnable: boolean;
    externalMinTransferAmt: number;
    externalMaxTransferAmt: number;
    isActive: boolean;
    isDefault: boolean;
}

export class Bo_WalletDataDto implements IBo_WalletDataDto {
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    tagName: string | undefined;
    isActive: boolean;
    network: NetworksDto;
    walletPolicies: WalletPoliciesDto[] | undefined;
    assets: AssetsDto[] | undefined;
    isCustoWalletCreated: boolean;

    constructor(data?: IBo_WalletDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.walletGroupsId = _data["walletGroupsId"];
            this.address = _data["address"];
            this.tagName = _data["tagName"];
            this.isActive = _data["isActive"];
            this.network = _data["network"] ? NetworksDto.fromJS(_data["network"]) : <any>undefined;
            if (Array.isArray(_data["walletPolicies"])) {
                this.walletPolicies = [] as any;
                for (let item of _data["walletPolicies"])
                    this.walletPolicies.push(WalletPoliciesDto.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets.push(AssetsDto.fromJS(item));
            }
            this.isCustoWalletCreated = _data["isCustoWalletCreated"];
        }
    }

    static fromJS(data: any): Bo_WalletDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new Bo_WalletDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["walletGroupsId"] = this.walletGroupsId;
        data["address"] = this.address;
        data["tagName"] = this.tagName;
        data["isActive"] = this.isActive;
        data["network"] = this.network ? this.network.toJSON() : <any>undefined;
        if (Array.isArray(this.walletPolicies)) {
            data["walletPolicies"] = [];
            for (let item of this.walletPolicies)
                data["walletPolicies"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        data["isCustoWalletCreated"] = this.isCustoWalletCreated;
        return data;
    }

    clone(): Bo_WalletDataDto {
        const json = this.toJSON();
        let result = new Bo_WalletDataDto();
        result.init(json);
        return result;
    }
}

export interface IBo_WalletDataDto {
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    tagName: string | undefined;
    isActive: boolean;
    network: NetworksDto;
    walletPolicies: WalletPoliciesDto[] | undefined;
    assets: AssetsDto[] | undefined;
    isCustoWalletCreated: boolean;
}

export class Bo_WalletGroupDataDto implements IBo_WalletGroupDataDto {
    userId: string;
    tagName: string | undefined;
    isActive: boolean;
    isMain: boolean;
    wallets: WalletsDto[] | undefined;
    isCustoWalletGroupCreated: boolean;
    custoWalletGroupId: string | undefined;
    custoWalletGroupName: string | undefined;

    constructor(data?: IBo_WalletGroupDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tagName = _data["tagName"];
            this.isActive = _data["isActive"];
            this.isMain = _data["isMain"];
            if (Array.isArray(_data["wallets"])) {
                this.wallets = [] as any;
                for (let item of _data["wallets"])
                    this.wallets.push(WalletsDto.fromJS(item));
            }
            this.isCustoWalletGroupCreated = _data["isCustoWalletGroupCreated"];
            this.custoWalletGroupId = _data["custoWalletGroupId"];
            this.custoWalletGroupName = _data["custoWalletGroupName"];
        }
    }

    static fromJS(data: any): Bo_WalletGroupDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new Bo_WalletGroupDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tagName"] = this.tagName;
        data["isActive"] = this.isActive;
        data["isMain"] = this.isMain;
        if (Array.isArray(this.wallets)) {
            data["wallets"] = [];
            for (let item of this.wallets)
                data["wallets"].push(item.toJSON());
        }
        data["isCustoWalletGroupCreated"] = this.isCustoWalletGroupCreated;
        data["custoWalletGroupId"] = this.custoWalletGroupId;
        data["custoWalletGroupName"] = this.custoWalletGroupName;
        return data;
    }

    clone(): Bo_WalletGroupDataDto {
        const json = this.toJSON();
        let result = new Bo_WalletGroupDataDto();
        result.init(json);
        return result;
    }
}

export interface IBo_WalletGroupDataDto {
    userId: string;
    tagName: string | undefined;
    isActive: boolean;
    isMain: boolean;
    wallets: WalletsDto[] | undefined;
    isCustoWalletGroupCreated: boolean;
    custoWalletGroupId: string | undefined;
    custoWalletGroupName: string | undefined;
}

export class Bo_WalletPoliciesDataDto implements IBo_WalletPoliciesDataDto {
    delegateUserId: string;
    walletsId: string;
    transferRules: TransferRulesDto;
    startDate: DateTime | undefined;
    expiryDate: DateTime | undefined;

    constructor(data?: IBo_WalletPoliciesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.delegateUserId = _data["delegateUserId"];
            this.walletsId = _data["walletsId"];
            this.transferRules = _data["transferRules"] ? TransferRulesDto.fromJS(_data["transferRules"]) : <any>undefined;
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Bo_WalletPoliciesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new Bo_WalletPoliciesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["delegateUserId"] = this.delegateUserId;
        data["walletsId"] = this.walletsId;
        data["transferRules"] = this.transferRules ? this.transferRules.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : <any>undefined;
        return data;
    }

    clone(): Bo_WalletPoliciesDataDto {
        const json = this.toJSON();
        let result = new Bo_WalletPoliciesDataDto();
        result.init(json);
        return result;
    }
}

export interface IBo_WalletPoliciesDataDto {
    delegateUserId: string;
    walletsId: string;
    transferRules: TransferRulesDto;
    startDate: DateTime | undefined;
    expiryDate: DateTime | undefined;
}

export class CoBoAccountInfoDto implements ICoBoAccountInfoDto {
    name: string | undefined;
    assets: CoBoAssetsDto[] | undefined;

    constructor(data?: ICoBoAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets.push(CoBoAssetsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CoBoAccountInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        return data;
    }

    clone(): CoBoAccountInfoDto {
        const json = this.toJSON();
        let result = new CoBoAccountInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAccountInfoDto {
    name: string | undefined;
    assets: CoBoAssetsDto[] | undefined;
}

export class CoBoAddressDto implements ICoBoAddressDto {
    coin: string | undefined;
    address: string | undefined;

    constructor(data?: ICoBoAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CoBoAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["address"] = this.address;
        return data;
    }

    clone(): CoBoAddressDto {
        const json = this.toJSON();
        let result = new CoBoAddressDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAddressDto {
    coin: string | undefined;
    address: string | undefined;
}

export class CoBoAddressesDto implements ICoBoAddressesDto {
    coin: string | undefined;
    addresses: string[] | undefined;

    constructor(data?: ICoBoAddressesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses.push(item);
            }
        }
    }

    static fromJS(data: any): CoBoAddressesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAddressesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item);
        }
        return data;
    }

    clone(): CoBoAddressesDto {
        const json = this.toJSON();
        let result = new CoBoAddressesDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAddressesDto {
    coin: string | undefined;
    addresses: string[] | undefined;
}

export class CoBoAssetsDto implements ICoBoAssetsDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    require_memo: boolean;
    minimum_deposit_threshold: string | undefined;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;
    abs_estimate_fee_usd: string | undefined;
    confirming_threshold: number;
    dust_threshold: number;
    token_address: string | undefined;

    constructor(data?: ICoBoAssetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.display_code = _data["display_code"];
            this.description = _data["description"];
            this._decimal = _data["_decimal"];
            this.can_deposit = _data["can_deposit"];
            this.can_withdraw = _data["can_withdraw"];
            this.require_memo = _data["require_memo"];
            this.minimum_deposit_threshold = _data["minimum_deposit_threshold"];
            this.balance = _data["balance"];
            this.abs_balance = _data["abs_balance"];
            this.fee_coin = _data["fee_coin"];
            this.abs_estimate_fee = _data["abs_estimate_fee"];
            this.abs_estimate_fee_usd = _data["abs_estimate_fee_usd"];
            this.confirming_threshold = _data["confirming_threshold"];
            this.dust_threshold = _data["dust_threshold"];
            this.token_address = _data["token_address"];
        }
    }

    static fromJS(data: any): CoBoAssetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoAssetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["display_code"] = this.display_code;
        data["description"] = this.description;
        data["_decimal"] = this._decimal;
        data["can_deposit"] = this.can_deposit;
        data["can_withdraw"] = this.can_withdraw;
        data["require_memo"] = this.require_memo;
        data["minimum_deposit_threshold"] = this.minimum_deposit_threshold;
        data["balance"] = this.balance;
        data["abs_balance"] = this.abs_balance;
        data["fee_coin"] = this.fee_coin;
        data["abs_estimate_fee"] = this.abs_estimate_fee;
        data["abs_estimate_fee_usd"] = this.abs_estimate_fee_usd;
        data["confirming_threshold"] = this.confirming_threshold;
        data["dust_threshold"] = this.dust_threshold;
        data["token_address"] = this.token_address;
        return data;
    }

    clone(): CoBoAssetsDto {
        const json = this.toJSON();
        let result = new CoBoAssetsDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoAssetsDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    require_memo: boolean;
    minimum_deposit_threshold: string | undefined;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;
    abs_estimate_fee_usd: string | undefined;
    confirming_threshold: number;
    dust_threshold: number;
    token_address: string | undefined;
}

export class CoBoSupportedSymbolsDto implements ICoBoSupportedSymbolsDto {
    success: boolean;
    result: CoBoSymbolsDto[] | undefined;

    constructor(data?: ICoBoSupportedSymbolsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(CoBoSymbolsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CoBoSupportedSymbolsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoSupportedSymbolsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }

    clone(): CoBoSupportedSymbolsDto {
        const json = this.toJSON();
        let result = new CoBoSupportedSymbolsDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoSupportedSymbolsDto {
    success: boolean;
    result: CoBoSymbolsDto[] | undefined;
}

export class CoBoSymbolsDto implements ICoBoSymbolsDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;

    constructor(data?: ICoBoSymbolsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.display_code = _data["display_code"];
            this.description = _data["description"];
            this._decimal = _data["_decimal"];
            this.can_deposit = _data["can_deposit"];
            this.can_withdraw = _data["can_withdraw"];
            this.balance = _data["balance"];
            this.abs_balance = _data["abs_balance"];
            this.fee_coin = _data["fee_coin"];
            this.abs_estimate_fee = _data["abs_estimate_fee"];
        }
    }

    static fromJS(data: any): CoBoSymbolsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoBoSymbolsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["display_code"] = this.display_code;
        data["description"] = this.description;
        data["_decimal"] = this._decimal;
        data["can_deposit"] = this.can_deposit;
        data["can_withdraw"] = this.can_withdraw;
        data["balance"] = this.balance;
        data["abs_balance"] = this.abs_balance;
        data["fee_coin"] = this.fee_coin;
        data["abs_estimate_fee"] = this.abs_estimate_fee;
        return data;
    }

    clone(): CoBoSymbolsDto {
        const json = this.toJSON();
        let result = new CoBoSymbolsDto();
        result.init(json);
        return result;
    }
}

export interface ICoBoSymbolsDto {
    coin: string | undefined;
    display_code: string | undefined;
    description: string | undefined;
    _decimal: number;
    can_deposit: boolean;
    can_withdraw: boolean;
    balance: string | undefined;
    abs_balance: string | undefined;
    fee_coin: string | undefined;
    abs_estimate_fee: string | undefined;
}

export class ConfigSettingsDto implements IConfigSettingsDto {
    id: number;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    name: string | undefined;
    value: string | undefined;

    constructor(data?: IConfigSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"] ? DateTime.fromISO(_data["createdTime"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedTime = _data["lastModifiedTime"] ? DateTime.fromISO(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ConfigSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime ? this.createdTime.toString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toString() : <any>undefined;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): ConfigSettingsDto {
        const json = this.toJSON();
        let result = new ConfigSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IConfigSettingsDto {
    id: number;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class ConfigSettingsDtoPagedListResponseDto implements IConfigSettingsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IConfigSettingsDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(ConfigSettingsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): ConfigSettingsDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSettingsDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): ConfigSettingsDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new ConfigSettingsDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IConfigSettingsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class ConfigSettingsDtoResponseDto implements IConfigSettingsDtoResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IConfigSettingsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? ConfigSettingsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): ConfigSettingsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSettingsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): ConfigSettingsDtoResponseDto {
        const json = this.toJSON();
        let result = new ConfigSettingsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IConfigSettingsDtoResponseDto {
    isSuccess: boolean;
    result: ConfigSettingsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class CreateConfigSettingsDto implements ICreateConfigSettingsDto {
    name: string;
    value: string;

    constructor(data?: ICreateConfigSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateConfigSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConfigSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): CreateConfigSettingsDto {
        const json = this.toJSON();
        let result = new CreateConfigSettingsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateConfigSettingsDto {
    name: string;
    value: string;
}

export class CreateWalletGroupsDto implements ICreateWalletGroupsDto {
    userId: string;
    tagName: string | undefined;

    constructor(data?: ICreateWalletGroupsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tagName = _data["tagName"];
        }
    }

    static fromJS(data: any): CreateWalletGroupsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWalletGroupsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tagName"] = this.tagName;
        return data;
    }

    clone(): CreateWalletGroupsDto {
        const json = this.toJSON();
        let result = new CreateWalletGroupsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWalletGroupsDto {
    userId: string;
    tagName: string | undefined;
}

export class CreateWalletPoliciesDto implements ICreateWalletPoliciesDto {
    delegateUserId: string;
    walletsId: string;
    transferRules: TransferRulesDto;
    startDate: DateTime | undefined;
    expiryDate: DateTime | undefined;

    constructor(data?: ICreateWalletPoliciesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.delegateUserId = _data["delegateUserId"];
            this.walletsId = _data["walletsId"];
            this.transferRules = _data["transferRules"] ? TransferRulesDto.fromJS(_data["transferRules"]) : <any>undefined;
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateWalletPoliciesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWalletPoliciesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["delegateUserId"] = this.delegateUserId;
        data["walletsId"] = this.walletsId;
        data["transferRules"] = this.transferRules ? this.transferRules.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : <any>undefined;
        return data;
    }

    clone(): CreateWalletPoliciesDto {
        const json = this.toJSON();
        let result = new CreateWalletPoliciesDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWalletPoliciesDto {
    delegateUserId: string;
    walletsId: string;
    transferRules: TransferRulesDto;
    startDate: DateTime | undefined;
    expiryDate: DateTime | undefined;
}

export class CreateWalletsDto implements ICreateWalletsDto {
    walletGroupsId: string;
    tagName: string;
    networkId: number | undefined;

    constructor(data?: ICreateWalletsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletGroupsId = _data["walletGroupsId"];
            this.tagName = _data["tagName"];
            this.networkId = _data["networkId"];
        }
    }

    static fromJS(data: any): CreateWalletsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWalletsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletGroupsId"] = this.walletGroupsId;
        data["tagName"] = this.tagName;
        data["networkId"] = this.networkId;
        return data;
    }

    clone(): CreateWalletsDto {
        const json = this.toJSON();
        let result = new CreateWalletsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWalletsDto {
    walletGroupsId: string;
    tagName: string;
    networkId: number | undefined;
}

export class EntityAssetsDto implements IEntityAssetsDto {
    id: string;
    assetData: AssetDataDto;

    constructor(data?: IEntityAssetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetData = _data["assetData"] ? AssetDataDto.fromJS(_data["assetData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityAssetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAssetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetData"] = this.assetData ? this.assetData.toJSON() : <any>undefined;
        return data;
    }

    clone(): EntityAssetsDto {
        const json = this.toJSON();
        let result = new EntityAssetsDto();
        result.init(json);
        return result;
    }
}

export interface IEntityAssetsDto {
    id: string;
    assetData: AssetDataDto;
}

export class EntitySymbolsDto implements IEntitySymbolsDto {
    id: string;
    symbolData: SymbolDataDto;

    constructor(data?: IEntitySymbolsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.symbolData = _data["symbolData"] ? SymbolDataDto.fromJS(_data["symbolData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntitySymbolsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySymbolsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["symbolData"] = this.symbolData ? this.symbolData.toJSON() : <any>undefined;
        return data;
    }

    clone(): EntitySymbolsDto {
        const json = this.toJSON();
        let result = new EntitySymbolsDto();
        result.init(json);
        return result;
    }
}

export interface IEntitySymbolsDto {
    id: string;
    symbolData: SymbolDataDto;
}

export class EntitySymbolsDtoPagedListResponseDto implements IEntitySymbolsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: EntitySymbolsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntitySymbolsDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(EntitySymbolsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntitySymbolsDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySymbolsDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntitySymbolsDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new EntitySymbolsDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntitySymbolsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: EntitySymbolsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntitySymbolsDtoResponseDto implements IEntitySymbolsDtoResponseDto {
    isSuccess: boolean;
    result: EntitySymbolsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntitySymbolsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? EntitySymbolsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntitySymbolsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySymbolsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntitySymbolsDtoResponseDto {
        const json = this.toJSON();
        let result = new EntitySymbolsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntitySymbolsDtoResponseDto {
    isSuccess: boolean;
    result: EntitySymbolsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntityTransactionsDto implements IEntityTransactionsDto {
    id: string;
    transactionData: TransactionDataDto;

    constructor(data?: IEntityTransactionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transactionData = _data["transactionData"] ? TransactionDataDto.fromJS(_data["transactionData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityTransactionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTransactionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transactionData"] = this.transactionData ? this.transactionData.toJSON() : <any>undefined;
        return data;
    }

    clone(): EntityTransactionsDto {
        const json = this.toJSON();
        let result = new EntityTransactionsDto();
        result.init(json);
        return result;
    }
}

export interface IEntityTransactionsDto {
    id: string;
    transactionData: TransactionDataDto;
}

export class EntityTransactionsDtoResponseDto implements IEntityTransactionsDtoResponseDto {
    isSuccess: boolean;
    result: EntityTransactionsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntityTransactionsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? EntityTransactionsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntityTransactionsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTransactionsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntityTransactionsDtoResponseDto {
        const json = this.toJSON();
        let result = new EntityTransactionsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntityTransactionsDtoResponseDto {
    isSuccess: boolean;
    result: EntityTransactionsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntityWalletGroupDto implements IEntityWalletGroupDto {
    id: string;
    walletGroupData: WalletGroupDataDto;

    constructor(data?: IEntityWalletGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.walletGroupData = _data["walletGroupData"] ? WalletGroupDataDto.fromJS(_data["walletGroupData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityWalletGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["walletGroupData"] = this.walletGroupData ? this.walletGroupData.toJSON() : <any>undefined;
        return data;
    }

    clone(): EntityWalletGroupDto {
        const json = this.toJSON();
        let result = new EntityWalletGroupDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletGroupDto {
    id: string;
    walletGroupData: WalletGroupDataDto;
}

export class EntityWalletGroupDtoIEnumerableResponseDto implements IEntityWalletGroupDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: EntityWalletGroupDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntityWalletGroupDtoIEnumerableResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(EntityWalletGroupDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntityWalletGroupDtoIEnumerableResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletGroupDtoIEnumerableResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntityWalletGroupDtoIEnumerableResponseDto {
        const json = this.toJSON();
        let result = new EntityWalletGroupDtoIEnumerableResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletGroupDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: EntityWalletGroupDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntityWalletGroupDtoResponseDto implements IEntityWalletGroupDtoResponseDto {
    isSuccess: boolean;
    result: EntityWalletGroupDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntityWalletGroupDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? EntityWalletGroupDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntityWalletGroupDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletGroupDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntityWalletGroupDtoResponseDto {
        const json = this.toJSON();
        let result = new EntityWalletGroupDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletGroupDtoResponseDto {
    isSuccess: boolean;
    result: EntityWalletGroupDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntityWalletPolicyDto implements IEntityWalletPolicyDto {
    id: string;
    walletPoliciesData: WalletPoliciesDataDto;

    constructor(data?: IEntityWalletPolicyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.walletPoliciesData = _data["walletPoliciesData"] ? WalletPoliciesDataDto.fromJS(_data["walletPoliciesData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityWalletPolicyDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletPolicyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["walletPoliciesData"] = this.walletPoliciesData ? this.walletPoliciesData.toJSON() : <any>undefined;
        return data;
    }

    clone(): EntityWalletPolicyDto {
        const json = this.toJSON();
        let result = new EntityWalletPolicyDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletPolicyDto {
    id: string;
    walletPoliciesData: WalletPoliciesDataDto;
}

export class EntityWalletPolicyDtoIEnumerableResponseDto implements IEntityWalletPolicyDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: EntityWalletPolicyDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntityWalletPolicyDtoIEnumerableResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(EntityWalletPolicyDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntityWalletPolicyDtoIEnumerableResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletPolicyDtoIEnumerableResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntityWalletPolicyDtoIEnumerableResponseDto {
        const json = this.toJSON();
        let result = new EntityWalletPolicyDtoIEnumerableResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletPolicyDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: EntityWalletPolicyDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntityWalletPolicyDtoResponseDto implements IEntityWalletPolicyDtoResponseDto {
    isSuccess: boolean;
    result: EntityWalletPolicyDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntityWalletPolicyDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? EntityWalletPolicyDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntityWalletPolicyDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletPolicyDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntityWalletPolicyDtoResponseDto {
        const json = this.toJSON();
        let result = new EntityWalletPolicyDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletPolicyDtoResponseDto {
    isSuccess: boolean;
    result: EntityWalletPolicyDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntityWalletsDto implements IEntityWalletsDto {
    id: string;
    walletData: WalletDataDto;

    constructor(data?: IEntityWalletsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.walletData = _data["walletData"] ? WalletDataDto.fromJS(_data["walletData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityWalletsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["walletData"] = this.walletData ? this.walletData.toJSON() : <any>undefined;
        return data;
    }

    clone(): EntityWalletsDto {
        const json = this.toJSON();
        let result = new EntityWalletsDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletsDto {
    id: string;
    walletData: WalletDataDto;
}

export class EntityWalletsDtoIEnumerableResponseDto implements IEntityWalletsDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: EntityWalletsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntityWalletsDtoIEnumerableResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(EntityWalletsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntityWalletsDtoIEnumerableResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletsDtoIEnumerableResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntityWalletsDtoIEnumerableResponseDto {
        const json = this.toJSON();
        let result = new EntityWalletsDtoIEnumerableResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletsDtoIEnumerableResponseDto {
    isSuccess: boolean;
    result: EntityWalletsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class EntityWalletsDtoResponseDto implements IEntityWalletsDtoResponseDto {
    isSuccess: boolean;
    result: EntityWalletsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IEntityWalletsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? EntityWalletsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): EntityWalletsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityWalletsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): EntityWalletsDtoResponseDto {
        const json = this.toJSON();
        let result = new EntityWalletsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEntityWalletsDtoResponseDto {
    isSuccess: boolean;
    result: EntityWalletsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class InvestmentDto implements IInvestmentDto {
    symbolsId: string;
    fromWalletId: string;
    amount: number;
    type: InvestmentType;
    twoFactorPin: string;

    constructor(data?: IInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolsId = _data["symbolsId"];
            this.fromWalletId = _data["fromWalletId"];
            this.amount = _data["amount"];
            this.type = _data["type"];
            this.twoFactorPin = _data["twoFactorPin"];
        }
    }

    static fromJS(data: any): InvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbolsId"] = this.symbolsId;
        data["fromWalletId"] = this.fromWalletId;
        data["amount"] = this.amount;
        data["type"] = this.type;
        data["twoFactorPin"] = this.twoFactorPin;
        return data;
    }

    clone(): InvestmentDto {
        const json = this.toJSON();
        let result = new InvestmentDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentDto {
    symbolsId: string;
    fromWalletId: string;
    amount: number;
    type: InvestmentType;
    twoFactorPin: string;
}

export enum InvestmentType {
    FD = 1,
    Game = 2,
}

export class NetworksDto implements INetworksDto {
    id: number;
    network: string | undefined;
    networkName: string | undefined;
    isActive: boolean;
    isDefault: boolean;

    constructor(data?: INetworksDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.network = _data["network"];
            this.networkName = _data["networkName"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): NetworksDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworksDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["network"] = this.network;
        data["networkName"] = this.networkName;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        return data;
    }

    clone(): NetworksDto {
        const json = this.toJSON();
        let result = new NetworksDto();
        result.init(json);
        return result;
    }
}

export interface INetworksDto {
    id: number;
    network: string | undefined;
    networkName: string | undefined;
    isActive: boolean;
    isDefault: boolean;
}

export class NetworksDtoPagedListResponseDto implements INetworksDtoPagedListResponseDto {
    isSuccess: boolean;
    result: NetworksDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: INetworksDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(NetworksDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): NetworksDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworksDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): NetworksDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new NetworksDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface INetworksDtoPagedListResponseDto {
    isSuccess: boolean;
    result: NetworksDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class NetworksDtoResponseDto implements INetworksDtoResponseDto {
    isSuccess: boolean;
    result: NetworksDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: INetworksDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? NetworksDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): NetworksDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworksDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): NetworksDtoResponseDto {
        const json = this.toJSON();
        let result = new NetworksDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface INetworksDtoResponseDto {
    isSuccess: boolean;
    result: NetworksDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class SymbolDataDto implements ISymbolDataDto {
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    regex: string | undefined;
    decimalPlaces: number;
    transferFee: number;
    minTransferAmt: number;
    maxTransferAmt: number;
    isPopular: boolean;
    sort: number;
    logoURL: string | undefined;

    constructor(data?: ISymbolDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.symbolName = _data["symbolName"];
            this.network = _data["network"];
            this.networkName = _data["networkName"];
            this.regex = _data["regex"];
            this.decimalPlaces = _data["decimalPlaces"];
            this.transferFee = _data["transferFee"];
            this.minTransferAmt = _data["minTransferAmt"];
            this.maxTransferAmt = _data["maxTransferAmt"];
            this.isPopular = _data["isPopular"];
            this.sort = _data["sort"];
            this.logoURL = _data["logoURL"];
        }
    }

    static fromJS(data: any): SymbolDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["symbolName"] = this.symbolName;
        data["network"] = this.network;
        data["networkName"] = this.networkName;
        data["regex"] = this.regex;
        data["decimalPlaces"] = this.decimalPlaces;
        data["transferFee"] = this.transferFee;
        data["minTransferAmt"] = this.minTransferAmt;
        data["maxTransferAmt"] = this.maxTransferAmt;
        data["isPopular"] = this.isPopular;
        data["sort"] = this.sort;
        data["logoURL"] = this.logoURL;
        return data;
    }

    clone(): SymbolDataDto {
        const json = this.toJSON();
        let result = new SymbolDataDto();
        result.init(json);
        return result;
    }
}

export interface ISymbolDataDto {
    symbol: string | undefined;
    symbolName: string | undefined;
    network: string | undefined;
    networkName: string | undefined;
    regex: string | undefined;
    decimalPlaces: number;
    transferFee: number;
    minTransferAmt: number;
    maxTransferAmt: number;
    isPopular: boolean;
    sort: number;
    logoURL: string | undefined;
}

export class SymbolsDto implements ISymbolsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    symbolData: Bo_SymbolDataDto;

    constructor(data?: ISymbolsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"] ? DateTime.fromISO(_data["createdTime"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedTime = _data["lastModifiedTime"] ? DateTime.fromISO(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.symbolData = _data["symbolData"] ? Bo_SymbolDataDto.fromJS(_data["symbolData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SymbolsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime ? this.createdTime.toString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toString() : <any>undefined;
        data["symbolData"] = this.symbolData ? this.symbolData.toJSON() : <any>undefined;
        return data;
    }

    clone(): SymbolsDto {
        const json = this.toJSON();
        let result = new SymbolsDto();
        result.init(json);
        return result;
    }
}

export interface ISymbolsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    symbolData: Bo_SymbolDataDto;
}

export class SymbolsDtoPagedListResponseDto implements ISymbolsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: SymbolsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: ISymbolsDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(SymbolsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): SymbolsDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolsDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): SymbolsDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new SymbolsDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISymbolsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: SymbolsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class SymbolsDtoResponseDto implements ISymbolsDtoResponseDto {
    isSuccess: boolean;
    result: SymbolsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: ISymbolsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? SymbolsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): SymbolsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): SymbolsDtoResponseDto {
        const json = this.toJSON();
        let result = new SymbolsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface ISymbolsDtoResponseDto {
    isSuccess: boolean;
    result: SymbolsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class TransactionDataDto implements ITransactionDataDto {
    userId: string;
    amount: number;
    symbol: string;
    network: string;
    fromWalletId: string;
    toWalletId: string;
    status: TransferStatus;

    constructor(data?: ITransactionDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.amount = _data["amount"];
            this.symbol = _data["symbol"];
            this.network = _data["network"];
            this.fromWalletId = _data["fromWalletId"];
            this.toWalletId = _data["toWalletId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TransactionDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["amount"] = this.amount;
        data["symbol"] = this.symbol;
        data["network"] = this.network;
        data["fromWalletId"] = this.fromWalletId;
        data["toWalletId"] = this.toWalletId;
        data["status"] = this.status;
        return data;
    }

    clone(): TransactionDataDto {
        const json = this.toJSON();
        let result = new TransactionDataDto();
        result.init(json);
        return result;
    }
}

export interface ITransactionDataDto {
    userId: string;
    amount: number;
    symbol: string;
    network: string;
    fromWalletId: string;
    toWalletId: string;
    status: TransferStatus;
}

export class TransferDto implements ITransferDto {
    symbolsId: string;
    fromWalletId: string;
    toWalletAddress: string;
    amount: number;
    twoFactorPin: string;

    constructor(data?: ITransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolsId = _data["symbolsId"];
            this.fromWalletId = _data["fromWalletId"];
            this.toWalletAddress = _data["toWalletAddress"];
            this.amount = _data["amount"];
            this.twoFactorPin = _data["twoFactorPin"];
        }
    }

    static fromJS(data: any): TransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbolsId"] = this.symbolsId;
        data["fromWalletId"] = this.fromWalletId;
        data["toWalletAddress"] = this.toWalletAddress;
        data["amount"] = this.amount;
        data["twoFactorPin"] = this.twoFactorPin;
        return data;
    }

    clone(): TransferDto {
        const json = this.toJSON();
        let result = new TransferDto();
        result.init(json);
        return result;
    }
}

export interface ITransferDto {
    symbolsId: string;
    fromWalletId: string;
    toWalletAddress: string;
    amount: number;
    twoFactorPin: string;
}

export class TransferLimitsDto implements ITransferLimitsDto {
    symbolsId: string;
    dayLimit: number;
    dayBalance: number;
    dayLastUpdatedDate: DateTime | undefined;
    weekLimit: number;
    weekBalance: number;
    weekLastUpdatedDate: DateTime | undefined;
    monthLimit: number;
    monthBalance: number;
    monthLastUpdatedDate: DateTime | undefined;
    yearLimit: number;
    yearBalance: number;
    yearLastUpdatedDate: DateTime | undefined;

    constructor(data?: ITransferLimitsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolsId = _data["symbolsId"];
            this.dayLimit = _data["dayLimit"];
            this.dayBalance = _data["dayBalance"];
            this.dayLastUpdatedDate = _data["dayLastUpdatedDate"] ? DateTime.fromISO(_data["dayLastUpdatedDate"].toString()) : <any>undefined;
            this.weekLimit = _data["weekLimit"];
            this.weekBalance = _data["weekBalance"];
            this.weekLastUpdatedDate = _data["weekLastUpdatedDate"] ? DateTime.fromISO(_data["weekLastUpdatedDate"].toString()) : <any>undefined;
            this.monthLimit = _data["monthLimit"];
            this.monthBalance = _data["monthBalance"];
            this.monthLastUpdatedDate = _data["monthLastUpdatedDate"] ? DateTime.fromISO(_data["monthLastUpdatedDate"].toString()) : <any>undefined;
            this.yearLimit = _data["yearLimit"];
            this.yearBalance = _data["yearBalance"];
            this.yearLastUpdatedDate = _data["yearLastUpdatedDate"] ? DateTime.fromISO(_data["yearLastUpdatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TransferLimitsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferLimitsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbolsId"] = this.symbolsId;
        data["dayLimit"] = this.dayLimit;
        data["dayBalance"] = this.dayBalance;
        data["dayLastUpdatedDate"] = this.dayLastUpdatedDate ? this.dayLastUpdatedDate.toString() : <any>undefined;
        data["weekLimit"] = this.weekLimit;
        data["weekBalance"] = this.weekBalance;
        data["weekLastUpdatedDate"] = this.weekLastUpdatedDate ? this.weekLastUpdatedDate.toString() : <any>undefined;
        data["monthLimit"] = this.monthLimit;
        data["monthBalance"] = this.monthBalance;
        data["monthLastUpdatedDate"] = this.monthLastUpdatedDate ? this.monthLastUpdatedDate.toString() : <any>undefined;
        data["yearLimit"] = this.yearLimit;
        data["yearBalance"] = this.yearBalance;
        data["yearLastUpdatedDate"] = this.yearLastUpdatedDate ? this.yearLastUpdatedDate.toString() : <any>undefined;
        return data;
    }

    clone(): TransferLimitsDto {
        const json = this.toJSON();
        let result = new TransferLimitsDto();
        result.init(json);
        return result;
    }
}

export interface ITransferLimitsDto {
    symbolsId: string;
    dayLimit: number;
    dayBalance: number;
    dayLastUpdatedDate: DateTime | undefined;
    weekLimit: number;
    weekBalance: number;
    weekLastUpdatedDate: DateTime | undefined;
    monthLimit: number;
    monthBalance: number;
    monthLastUpdatedDate: DateTime | undefined;
    yearLimit: number;
    yearBalance: number;
    yearLastUpdatedDate: DateTime | undefined;
}

export class TransferRulesDto implements ITransferRulesDto {
    transferLimits: TransferLimitsDto[] | undefined;
    whitelistAddresses: WhitelistAddressesDto[] | undefined;
    isTransferApprovalNeeded: boolean;

    constructor(data?: ITransferRulesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["transferLimits"])) {
                this.transferLimits = [] as any;
                for (let item of _data["transferLimits"])
                    this.transferLimits.push(TransferLimitsDto.fromJS(item));
            }
            if (Array.isArray(_data["whitelistAddresses"])) {
                this.whitelistAddresses = [] as any;
                for (let item of _data["whitelistAddresses"])
                    this.whitelistAddresses.push(WhitelistAddressesDto.fromJS(item));
            }
            this.isTransferApprovalNeeded = _data["isTransferApprovalNeeded"];
        }
    }

    static fromJS(data: any): TransferRulesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRulesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transferLimits)) {
            data["transferLimits"] = [];
            for (let item of this.transferLimits)
                data["transferLimits"].push(item.toJSON());
        }
        if (Array.isArray(this.whitelistAddresses)) {
            data["whitelistAddresses"] = [];
            for (let item of this.whitelistAddresses)
                data["whitelistAddresses"].push(item.toJSON());
        }
        data["isTransferApprovalNeeded"] = this.isTransferApprovalNeeded;
        return data;
    }

    clone(): TransferRulesDto {
        const json = this.toJSON();
        let result = new TransferRulesDto();
        result.init(json);
        return result;
    }
}

export interface ITransferRulesDto {
    transferLimits: TransferLimitsDto[] | undefined;
    whitelistAddresses: WhitelistAddressesDto[] | undefined;
    isTransferApprovalNeeded: boolean;
}

export enum TransferStatus {
    Pending = 1,
    Completed = 2,
    Failed = 3,
    PendingApproval = 4,
    Approved = 5,
    Rejected = 6,
}

export class UpdateWalletBalanceDto implements IUpdateWalletBalanceDto {
    walletsId: string;
    symbolsId: string;
    amount: number;

    constructor(data?: IUpdateWalletBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletsId = _data["walletsId"];
            this.symbolsId = _data["symbolsId"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): UpdateWalletBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWalletBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletsId"] = this.walletsId;
        data["symbolsId"] = this.symbolsId;
        data["amount"] = this.amount;
        return data;
    }

    clone(): UpdateWalletBalanceDto {
        const json = this.toJSON();
        let result = new UpdateWalletBalanceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWalletBalanceDto {
    walletsId: string;
    symbolsId: string;
    amount: number;
}

export class UpdateWalletDto implements IUpdateWalletDto {
    walletsId: string;
    isActive: boolean | undefined;
    tagName: string | undefined;

    constructor(data?: IUpdateWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletsId = _data["walletsId"];
            this.isActive = _data["isActive"];
            this.tagName = _data["tagName"];
        }
    }

    static fromJS(data: any): UpdateWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletsId"] = this.walletsId;
        data["isActive"] = this.isActive;
        data["tagName"] = this.tagName;
        return data;
    }

    clone(): UpdateWalletDto {
        const json = this.toJSON();
        let result = new UpdateWalletDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWalletDto {
    walletsId: string;
    isActive: boolean | undefined;
    tagName: string | undefined;
}

export class WalletDataDto implements IWalletDataDto {
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    tagName: string | undefined;
    isActive: boolean;
    network: NetworksDto;
    walletPolicies: WalletPoliciesDto[] | undefined;
    assets: EntityAssetsDto[] | undefined;

    constructor(data?: IWalletDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.walletGroupsId = _data["walletGroupsId"];
            this.address = _data["address"];
            this.tagName = _data["tagName"];
            this.isActive = _data["isActive"];
            this.network = _data["network"] ? NetworksDto.fromJS(_data["network"]) : <any>undefined;
            if (Array.isArray(_data["walletPolicies"])) {
                this.walletPolicies = [] as any;
                for (let item of _data["walletPolicies"])
                    this.walletPolicies.push(WalletPoliciesDto.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets.push(EntityAssetsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["walletGroupsId"] = this.walletGroupsId;
        data["address"] = this.address;
        data["tagName"] = this.tagName;
        data["isActive"] = this.isActive;
        data["network"] = this.network ? this.network.toJSON() : <any>undefined;
        if (Array.isArray(this.walletPolicies)) {
            data["walletPolicies"] = [];
            for (let item of this.walletPolicies)
                data["walletPolicies"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        return data;
    }

    clone(): WalletDataDto {
        const json = this.toJSON();
        let result = new WalletDataDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDataDto {
    userId: string;
    walletGroupsId: string;
    address: string | undefined;
    tagName: string | undefined;
    isActive: boolean;
    network: NetworksDto;
    walletPolicies: WalletPoliciesDto[] | undefined;
    assets: EntityAssetsDto[] | undefined;
}

export class WalletGroupDataDto implements IWalletGroupDataDto {
    userId: string;
    tagName: string | undefined;
    isActive: boolean;
    isMain: boolean;
    wallets: EntityWalletsDto[] | undefined;

    constructor(data?: IWalletGroupDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tagName = _data["tagName"];
            this.isActive = _data["isActive"];
            this.isMain = _data["isMain"];
            if (Array.isArray(_data["wallets"])) {
                this.wallets = [] as any;
                for (let item of _data["wallets"])
                    this.wallets.push(EntityWalletsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletGroupDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tagName"] = this.tagName;
        data["isActive"] = this.isActive;
        data["isMain"] = this.isMain;
        if (Array.isArray(this.wallets)) {
            data["wallets"] = [];
            for (let item of this.wallets)
                data["wallets"].push(item.toJSON());
        }
        return data;
    }

    clone(): WalletGroupDataDto {
        const json = this.toJSON();
        let result = new WalletGroupDataDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupDataDto {
    userId: string;
    tagName: string | undefined;
    isActive: boolean;
    isMain: boolean;
    wallets: EntityWalletsDto[] | undefined;
}

export class WalletGroupsDto implements IWalletGroupsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    isDeleted: boolean;
    deletedBy: string | undefined;
    deletedTime: DateTime | undefined;
    walletGroupData: Bo_WalletGroupDataDto;

    constructor(data?: IWalletGroupsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"] ? DateTime.fromISO(_data["createdTime"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedTime = _data["lastModifiedTime"] ? DateTime.fromISO(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deletedBy = _data["deletedBy"];
            this.deletedTime = _data["deletedTime"] ? DateTime.fromISO(_data["deletedTime"].toString()) : <any>undefined;
            this.walletGroupData = _data["walletGroupData"] ? Bo_WalletGroupDataDto.fromJS(_data["walletGroupData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletGroupsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime ? this.createdTime.toString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deletedBy"] = this.deletedBy;
        data["deletedTime"] = this.deletedTime ? this.deletedTime.toString() : <any>undefined;
        data["walletGroupData"] = this.walletGroupData ? this.walletGroupData.toJSON() : <any>undefined;
        return data;
    }

    clone(): WalletGroupsDto {
        const json = this.toJSON();
        let result = new WalletGroupsDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    isDeleted: boolean;
    deletedBy: string | undefined;
    deletedTime: DateTime | undefined;
    walletGroupData: Bo_WalletGroupDataDto;
}

export class WalletGroupsDtoPagedListResponseDto implements IWalletGroupsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletGroupsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletGroupsDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(WalletGroupsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletGroupsDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupsDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletGroupsDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new WalletGroupsDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletGroupsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletGroupsDtoResponseDto implements IWalletGroupsDtoResponseDto {
    isSuccess: boolean;
    result: WalletGroupsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletGroupsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? WalletGroupsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletGroupsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletGroupsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletGroupsDtoResponseDto {
        const json = this.toJSON();
        let result = new WalletGroupsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletGroupsDtoResponseDto {
    isSuccess: boolean;
    result: WalletGroupsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletPoliciesDataDto implements IWalletPoliciesDataDto {
    delegateUserId: string;
    walletsId: string;
    transferRules: TransferRulesDto;
    startDate: DateTime | undefined;
    expiryDate: DateTime | undefined;

    constructor(data?: IWalletPoliciesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.delegateUserId = _data["delegateUserId"];
            this.walletsId = _data["walletsId"];
            this.transferRules = _data["transferRules"] ? TransferRulesDto.fromJS(_data["transferRules"]) : <any>undefined;
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletPoliciesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletPoliciesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["delegateUserId"] = this.delegateUserId;
        data["walletsId"] = this.walletsId;
        data["transferRules"] = this.transferRules ? this.transferRules.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : <any>undefined;
        return data;
    }

    clone(): WalletPoliciesDataDto {
        const json = this.toJSON();
        let result = new WalletPoliciesDataDto();
        result.init(json);
        return result;
    }
}

export interface IWalletPoliciesDataDto {
    delegateUserId: string;
    walletsId: string;
    transferRules: TransferRulesDto;
    startDate: DateTime | undefined;
    expiryDate: DateTime | undefined;
}

export class WalletPoliciesDto implements IWalletPoliciesDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    isDeleted: boolean;
    deletedBy: string | undefined;
    deletedTime: DateTime | undefined;
    walletPoliciesData: Bo_WalletPoliciesDataDto;

    constructor(data?: IWalletPoliciesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"] ? DateTime.fromISO(_data["createdTime"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedTime = _data["lastModifiedTime"] ? DateTime.fromISO(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deletedBy = _data["deletedBy"];
            this.deletedTime = _data["deletedTime"] ? DateTime.fromISO(_data["deletedTime"].toString()) : <any>undefined;
            this.walletPoliciesData = _data["walletPoliciesData"] ? Bo_WalletPoliciesDataDto.fromJS(_data["walletPoliciesData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletPoliciesDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletPoliciesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime ? this.createdTime.toString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deletedBy"] = this.deletedBy;
        data["deletedTime"] = this.deletedTime ? this.deletedTime.toString() : <any>undefined;
        data["walletPoliciesData"] = this.walletPoliciesData ? this.walletPoliciesData.toJSON() : <any>undefined;
        return data;
    }

    clone(): WalletPoliciesDto {
        const json = this.toJSON();
        let result = new WalletPoliciesDto();
        result.init(json);
        return result;
    }
}

export interface IWalletPoliciesDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    isDeleted: boolean;
    deletedBy: string | undefined;
    deletedTime: DateTime | undefined;
    walletPoliciesData: Bo_WalletPoliciesDataDto;
}

export class WalletPoliciesDtoPagedListResponseDto implements IWalletPoliciesDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletPoliciesDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletPoliciesDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(WalletPoliciesDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletPoliciesDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletPoliciesDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletPoliciesDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new WalletPoliciesDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletPoliciesDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletPoliciesDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletPoliciesDtoResponseDto implements IWalletPoliciesDtoResponseDto {
    isSuccess: boolean;
    result: WalletPoliciesDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletPoliciesDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? WalletPoliciesDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletPoliciesDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletPoliciesDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletPoliciesDtoResponseDto {
        const json = this.toJSON();
        let result = new WalletPoliciesDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletPoliciesDtoResponseDto {
    isSuccess: boolean;
    result: WalletPoliciesDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletsDto implements IWalletsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    isDeleted: boolean;
    deletedBy: string | undefined;
    deletedTime: DateTime | undefined;
    walletData: Bo_WalletDataDto;

    constructor(data?: IWalletsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.createdTime = _data["createdTime"] ? DateTime.fromISO(_data["createdTime"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedTime = _data["lastModifiedTime"] ? DateTime.fromISO(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deletedBy = _data["deletedBy"];
            this.deletedTime = _data["deletedTime"] ? DateTime.fromISO(_data["deletedTime"].toString()) : <any>undefined;
            this.walletData = _data["walletData"] ? Bo_WalletDataDto.fromJS(_data["walletData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["createdTime"] = this.createdTime ? this.createdTime.toString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deletedBy"] = this.deletedBy;
        data["deletedTime"] = this.deletedTime ? this.deletedTime.toString() : <any>undefined;
        data["walletData"] = this.walletData ? this.walletData.toJSON() : <any>undefined;
        return data;
    }

    clone(): WalletsDto {
        const json = this.toJSON();
        let result = new WalletsDto();
        result.init(json);
        return result;
    }
}

export interface IWalletsDto {
    id: string;
    createdBy: string | undefined;
    createdTime: DateTime;
    lastModifiedBy: string | undefined;
    lastModifiedTime: DateTime | undefined;
    isDeleted: boolean;
    deletedBy: string | undefined;
    deletedTime: DateTime | undefined;
    walletData: Bo_WalletDataDto;
}

export class WalletsDtoPagedListResponseDto implements IWalletsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletsDtoPagedListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(WalletsDto.fromJS(item));
            }
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletsDtoPagedListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletsDtoPagedListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletsDtoPagedListResponseDto {
        const json = this.toJSON();
        let result = new WalletsDtoPagedListResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletsDtoPagedListResponseDto {
    isSuccess: boolean;
    result: WalletsDto[] | undefined;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WalletsDtoResponseDto implements IWalletsDtoResponseDto {
    isSuccess: boolean;
    result: WalletsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;

    constructor(data?: IWalletsDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.result = _data["result"] ? WalletsDto.fromJS(_data["result"]) : <any>undefined;
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages.push(item);
            }
        }
    }

    static fromJS(data: any): WalletsDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletsDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }

    clone(): WalletsDtoResponseDto {
        const json = this.toJSON();
        let result = new WalletsDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IWalletsDtoResponseDto {
    isSuccess: boolean;
    result: WalletsDto;
    displayMessage: string | undefined;
    errorMessages: string[] | undefined;
}

export class WhitelistAddressesDto implements IWhitelistAddressesDto {
    address: string;
    tagName: string | undefined;

    constructor(data?: IWhitelistAddressesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.tagName = _data["tagName"];
        }
    }

    static fromJS(data: any): WhitelistAddressesDto {
        data = typeof data === 'object' ? data : {};
        let result = new WhitelistAddressesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["tagName"] = this.tagName;
        return data;
    }

    clone(): WhitelistAddressesDto {
        const json = this.toJSON();
        let result = new WhitelistAddressesDto();
        result.init(json);
        return result;
    }
}

export interface IWhitelistAddressesDto {
    address: string;
    tagName: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}